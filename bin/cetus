#!/usr/bin/env ruby
# --------------------------------------------------------------------------- #
#         File: cetus
#  Description: Fast file navigation, a tiny version of zfm
#               but with a different indexing mechanism
#       Author: rkumar http://github.com/rkumar/cetus/
#         Date: 2013-02-17 - 17:48
#      License: GPL
#  Last update: 2019-04-11 14:52
# --------------------------------------------------------------------------- #
#  cetus.rb  Copyright (C) 2012-2019 rahul kumar
# == CHANGELOG
# 2019-03-24 - adding colors per line, but columnate will have to change
#  since size calc will include color codes. Same for truncate
# 2019-02-20 - added smcup and rmcup so alt-screen is used. works a bit
# 2019-03-04 - change clear to go to 0,0 and clear down to reduce pollution
# 2019-03-04 - changed quit to q (earlier Q)
# 2019-03-04 - first dirs then files
# 2019-03-22 - refactoring the code, esp run()
#  == TODO

require 'readline'
require 'io/wait'
# http://www.ruby-doc.org/stdlib-1.9.3/libdoc/shellwords/rdoc/Shellwords.html
require 'shellwords'
# https://docs.ruby-lang.org/en/2.6.0/FileUtils.html
require 'fileutils'
require 'logger'
# @log = Logger.new(File.expand_path '~/tmp/log.txt')
@log = Logger.new('log.txt')

## INSTALLATION
# copy into PATH
# alias c=~/bin/cetus.rb
# c

VERSION = '0.1.35.0'.freeze
CONFIG_PATH = ENV['XDG_CONFIG_HOME'] || File.join(ENV['HOME'], '.config')
CONFIG_FILE = "#{CONFIG_PATH}/cetus/conf.yml".freeze

$bindings = {
  '`' => 'main_menu',
  '=' => 'toggle_menu',
  'M-s' => 'selection_menu',
  'M-o' => 'order_menu',
  'ENTER' => 'select_current',
  'C-p' => 'page_current',
  'C-e' => 'edit_current',
  'C-o' => 'open_current',
  'C-s' => 'toggle_select',
  'C-r' => 'reduce',
  'C-g' => 'debug_vars',
  '*' => 'toggle_selection_mode',
  'M-a' => 'select_all',
  'M-A' => 'unselect_all',
  '!' => 'execute',
  ',' => 'goto_parent_dir',
  '~' => 'goto_home_dir',
  '-' => 'goto_previous_dir',
  '+' => 'goto_dir',          # 2019-03-07 - TODO: change binding
  '.' => 'pop_dir',
  ':' => 'subcommand',
  "'" => 'goto_bookmark',
  '"' => 'file_starting_with',
  '/' => 'enter_regex',
  'M-p' => 'prev_page',
  'M-n' => 'next_page',
  'SPACE' => 'next_page:Page Down',
  'M-f' => 'select_from_visited_files',
  'M-d' => 'select_from_used_dirs',
  'M-b' => 'bookmark_menu',
  'M-m' => 'create_bookmark',
  'M-M' => 'view_bookmarks',
  'C-c' => 'escape',
  'ESCAPE' => 'escape',
  'TAB' => 'views',
  'C-i' => 'views',
  # '?' => 'dirtree',
  'D' => 'delete_file',
  'M' => 'file_actions most',
  'q' => 'quit_command', # was Q now q 2019-03-04 -
  # "RIGHT"   => "column_next",
  'RIGHT' => 'select_current', # changed 2018-03-12 - for faster navigation
  'LEFT' => 'goto_parent_dir', # changed on 2018-03-12 - earlier column_next 1
  ']' => 'column_next: goto next column',
  '[' => 'column_next 1: goto previous column',
  'C-x' => 'file_actions',
  'M--' => 'columns_incdec -1: reduce column width',
  'M-+' => 'columns_incdec 1: increase column width',
  'S' => 'command_file list y ls -lh',
  'L' => 'command_file Page n less',
  'C-d' => 'cursor_scroll_dn',
  'C-b' => 'cursor_scroll_up',
  'UP' => 'cursor_up',
  'DOWN' => 'cursor_dn',
  'C-SPACE' => 'visual_mode_toggle',
  '@' => 'scripts',
  '#' => 'generators',

  '?' => 'print_help',
  'F1' => 'print_help',
  'F2' => 'child_dirs',
  'F3' => 'dirtree',
  'F4' => 'tree',
  'S-F1' => 'dirtree',
  'S-F2' => 'tree'

}

## clean this up a bit, copied from shell program and macro'd
$kh = {}
$kh["\eOP"] = 'F1'
$kh["\e[A"] = 'UP'
$kh["\e[5~"] = 'PGUP'
$kh[''] = 'ESCAPE'
KEY_PGDN = "\e[6~".freeze
KEY_PGUP = "\e[5~".freeze
## I needed to replace the O with a [ for this to work
#  in Vim Home comes as ^[OH whereas on the command line it is correct as ^[[H
KEY_HOME = '[H'.freeze
KEY_END = "\e[F".freeze
KEY_F1 = "\eOP".freeze
KEY_UP = "\e[A".freeze
KEY_DOWN = "\e[B".freeze

$kh[KEY_PGDN] = 'PgDn'
$kh[KEY_PGUP] = 'PgUp'
$kh[KEY_HOME] = 'Home'
$kh[KEY_END] = 'End'
$kh[KEY_F1] = 'F1'
$kh[KEY_UP] = 'UP'
$kh[KEY_DOWN] = 'DOWN'
KEY_LEFT = '[D'.freeze
KEY_RIGHT = '[C'.freeze
$kh["\eOQ"] = 'F2'
$kh["\eOR"] = 'F3'
$kh["\eOS"] = 'F4'
$kh[KEY_LEFT] = 'LEFT'
$kh[KEY_RIGHT] = 'RIGHT'
KEY_F5 = '[15~'.freeze
KEY_F6 = '[17~'.freeze
KEY_F7 = '[18~'.freeze
KEY_F8 = '[19~'.freeze
KEY_F9 = '[20~'.freeze
KEY_F10 = '[21~'.freeze
KEY_S_F1 = '[1;2P'.freeze
$kh[KEY_F5] = 'F5'
$kh[KEY_F6] = 'F6'
$kh[KEY_F7] = 'F7'
$kh[KEY_F8] = 'F8'
$kh[KEY_F9] = 'F9'
$kh[KEY_F10] = 'F10'
# testing out shift+Function. these are the codes my kb generates
$kh[KEY_S_F1] = 'S-F1'
$kh['[1;2Q'] = 'S-F2'

# copied from fff
def clear_screen
  # Only clear the scrolling window (dir item list).
  # '\e[%sH':    Move cursor to bottom of scroll area.
  # '\e[9999C':  Move cursor to right edge of the terminal.
  # '\e[1J':     Clear screen to top left corner (from cursor up).
  # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
  # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
  #              Also sets cursor to (0,0).
  # ENV["TMUX:+\e[2J]"],
  printf("\e[%sH\e[9999C\e[1J\e[1;%sr", \
         $glines - 0, # was 2
         $glines) # was grows
end

# copied from fff
# Call before shelling to editor pager and when exiting
def reset_terminal
  # Reset the terminal to a useable state (undo all changes).
  # '\e[?7h':  Re-enable line wrapping.
  # '\e[?25h': Unhide the cursor.
  # '\e[2J':   Clear the terminal.
  # '\e[;r':   Set the scroll region to its default value.
  #            Also sets cursor to (0,0).
  # '\e[?1049l: Restore main screen buffer.
  print "\e[?7h\e[?25h\e[2J\e[;r\e[?1049l"

  # Show user input.
  system 'stty echo'
end

# copied from fff
# call AFTER shelling to most or vim
def setup_terminal
  # Setup the terminal for the TUI.
  # '\e[?1049h': Use alternative screen buffer. smcup
  # '\e[?7l':    Disable line wrapping.
  # '\e[?25l':   Hide the cursor.
  # '\e[2J':     Clear the screen.
  # '\e[1;Nr':   Limit scrolling to scrolling area.
  #              Also sets cursor to (0,0).
  # printf("\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr", $glines)
  # 2019-03-29 - XXX temporarily not hiding cursor to see if we can place it.
  printf("\e[?1049h\e[?7l\e[?25h\e[2J\e[1;%sr", $glines)
  # earlier glines was grows

  # Hide echoing of user input
  system 'stty -echo'
end

# wrap readline so C-c can be ignored, but blank is taken as default
def readline prompt='>'
  clear_last_line
  print "\r"
  # do we need to clear till end of line, see enter_regex commented
  # unhide cursor
  print "\e[?25h"
  system 'stty echo'
  begin
    target = Readline.readline(prompt, true)
  rescue Interrupt
    return nil
  ensure
    # hide cursor
    # NO LONGER HIDING cursor 2019-03-29 -
    # print "\e[?25l"
    system 'stty -echo'
  end
  target.chomp
end

## get a character from user and return as a string
# Adapted from:
# http://stackoverflow.com/questions/174933/how-to-get-a-single-character-without-pressing-enter/8274275#8274275
# Need to take complex keys and match against a hash.
def get_char
  system('stty raw -echo 2>/dev/null') # turn raw input on
  c = nil
  # if $stdin.ready?
  c = $stdin.getc
  cn = c.ord
  return 'ENTER' if cn == 10 || cn == 13
  return 'BACKSPACE' if cn == 127
  return 'C-SPACE' if cn == 0
  return 'SPACE' if cn == 32
  # next does not seem to work, you need to bind C-i
  return 'TAB' if cn == 8

  if cn >= 0 && cn < 27
    x = cn + 96
    return "C-#{x.chr}"
  end
  if c == ''
    buff = c.chr
    loop do
      k = nil
      if $stdin.ready?
        k = $stdin.getc
        # puts "got #{k}"
        buff += k.chr
      else
        x = $kh[buff]
        return x if x

        # puts "returning with  #{buff}"
        if buff.size == 2
          ## possibly a meta/alt char
          k = buff[-1]
          return "M-#{k.chr}"
        end
        return buff
      end
    end
  end
  # end
  return c.chr if c
ensure
  # system('stty -raw echo 2>/dev/null') # turn raw input on
  # 2019-03-29 - echo was causing printing of arrow key code on screen
  # if moving fast
  system('stty -raw 2>/dev/null') # turn raw input on
end

## GLOBALS
# hints or shortcuts to get to files without moving
$IDX = ('a'..'y').to_a
$IDX.delete 'q'
$IDX.concat ('za'..'zz').to_a
$IDX.concat ('Za'..'Zz').to_a
$IDX.concat ('ZA'..'ZZ').to_a

$selected_files = []
$bookmarks = {}
$mode = nil
$glines = `tput lines`.to_i
$gcols = `tput cols`.to_i
$grows = $glines - 3  # can be a func
# $pagesize = 60
$gviscols = 3
$pagesize = $grows * $gviscols # can be a func
$stact = 0 # used when panning a folder to next column
# $editor_mode = true
$editor_mode = false # changed 2018-03-12 - so we start in pager mode
$enhanced_mode = true
$visual_block_start = nil
$pager_command = {
  text: 'most',
  image: 'open',
  zip: 'tar ztvf %% | most',
  unknown: 'open'
}
$dir_position = {}
$movement = $old_cursor = nil  # cursor movement has happened only, don't repaint
$selection_mode = 1 # single select
@group_dirs = true
# truncate long filenames from :right, :left or :center.
@truncate_from = :center
@filename_status_line = true

## ----------------- CONSTANTS ----------------- ##
GMARK = '*'.freeze
CURMARK = '>'.freeze
MSCROLL = 10
SPACE = ' '.freeze
SEPARATOR = '-------'.freeze
CLEAR      = "\e[0m".freeze
BOLD       = "\e[1m".freeze
BOLD_OFF = "\e[22m".freeze
RED = "\e[31m".freeze
ON_RED = "\e[41m".freeze
GREEN      = "\e[32m".freeze
YELLOW     = "\e[33m".freeze
BLUE       = "\e[1;34m".freeze
MAGENTA    = "\e[35m".freeze
CYAN       = "\e[36m".freeze

ON_BLUE    = "\e[44m".freeze
REVERSE    = "\e[7m".freeze
UNDERLINE    = "\e[4m".freeze
CURSOR_COLOR = REVERSE

# NOTE: that osx uses LSCOLORS which only has colors for filetypes not
#  extensions and patterns which LS_COLORS has.
# LS_COLORS contains 2 character filetype colors. ex executable mi broken link
#   extension based colros starting with '*.'
#   file pattern starting with '*' and a character that is not .
#   File.ftype(path) returns
#   file, directory di, characterSpecial cd, blockSpecial bd, fifo pi, link ln, socket so, or unknown

# This hash contains color codes for extensions. It is updated from
# LS_COLORS.
$ls_color = {
  '.rb' => RED,
  '.tgz' => MAGENTA,
  '.zip' => MAGENTA,
  '.torrent' => GREEN,
  '.srt' => GREEN,
  '.sh' => CYAN
}
# This hash contains colors for file patterns, updated from LS_COLORS
$ls_pattern = {}
# This hash contains colors for file types, updated from LS_COLORS
# Default values in absence of LS_COLORS
$ls_ftype = {
  'directory' =>  BLUE,
  'link'      =>  "\e[01;36m",
  'mi'        =>  "\e[01;31;7m",
  'or'        =>  "\e[40;31;01m",
  'ex'        =>  "\e[01;32m"
}
## --------------------------------------------- ##

$patt = nil
$ignorecase = true
$quitting = false
$modified = $writing = false
$visited_files = []
## dir stack for popping
$visited_dirs = []
## dirs where some work has been done, for saving and restoring
$used_dirs = []
# zsh o = order m = modified time
$default_sort_order = 'Om'
$sorto = $default_sort_order
$viewctr = 0
$history = []
## sta is where view (viewport) begins, cursor is current row/file
$sta = $cursor = 0
$visual_mode = false
$status_color = 4 # status line, can be 2 3 4 5 6

# Menubar on top of screen
@help = "#{BOLD}?#{BOLD_OFF} Help   #{BOLD}`#{BOLD_OFF} Menu   #{BOLD}!#{BOLD_OFF} Execute   #{BOLD}=#{BOLD_OFF} Toggle   #{BOLD}C-x#{BOLD_OFF} File Actions  #{BOLD}q#{BOLD_OFF} Quit "

# ------------------- read_directory ------------------ #
def read_directory
  rescan_required false

  # http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html
  # zsh print -rl
  # -l Print the arguments separated by newlines instead of spaces.
  # -r Ignore the escape conventions of echo.
  # zshglob M = MARK_DIRS

  $filterstr ||= 'M'
  # $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}#{$filterstr})'`.split("\n")
  $files = list_files
  $files = group_directories_first($files) if @group_dirs
  return unless $enhanced_mode

  enhance_file_list
  $files = $files.uniq
end

# return a list of directory contents sorted as per sort order
# NOTE: FNM_CASEFOLD does not work with Dir.glob
def list_files dir='*', sorto=$sorto, hidden=$hidden, filter=$filterstr

  dir += '/*' if File.directory?(dir)
  dir = dir.gsub('//', '/')

  # decide sort method based on second character
  # first char is o or O (reverse)
  # second char is macLn etc (as in zsh glob)
  so = sorto ? sorto[1] : nil
  func = case so
         when 'm'
           :mtime
         when 'a'
           :atime
         when 'c'
           :ctime
         when 'L'
           :size
         when 'n'
           :path
         when 'x'
           :extname
         end

  # sort by time and then reverse so latest first.
  sorted_files = if hidden == 'D'
                   Dir.glob(dir, File::FNM_DOTMATCH)
                 else
                   Dir.glob(dir)
                 end

  # WARN: crashes on a dead link since no mtime
  # HACK: use first files return value for bad link
  if func
    sorted_files = sorted_files.sort_by do |f|
      if File.exist? f
        File.send(func, f)
      else
        sys_stat(func, f)
      end
    end
  end

  sorted_files.sort! { |w1, w2| w1.casecmp(w2) } if func == :path && $ignorecase

  # zsh gives mtime sort with latest first, ruby gives latest last
  sorted_files.reverse! if sorto[0] == 'O'

  # add slash to directories
  sorted_files = add_slash sorted_files
  return sorted_files
end
# ------------- end of read_directory --------------------------------#

# Deal with dead links.
def sys_stat func, file
  return unless File.symlink? file

  # lstat does not respond to path and extname
  return File.send(func, file) unless File.lstat(file).respond_to? func

  return File.lstat(file).send(func)
end

# ------------------- create_viewport ------------------ #
def create_viewport
  $view = if $patt
            if $ignorecase
              $files.grep(/#{$patt}/i)
            else
              $files.grep(/#{$patt}/)
            end
          else
            $files
          end

  fl = $view.size
  $sta = 0 if $sta >= fl || $sta < 0
  $cursor = 0 if $cursor >= fl || $cursor < 0

  # NOTE if we make cursor zero, then it can be < sta so in the next line
  #  it will be made equal to sta which we may not want
  $cursor = $sta if $sta > $cursor

  # viewport are the files that are visible, subset of view
  $viewport = $view[$sta, $pagesize]
end
# ------------- end of create_viewport --------------------------------#

# ------------------- print_title ------------------ #
def print_title

  # print help line and version
  print "#{GREEN}#{@help}  #{BLUE}cetus #{VERSION}#{CLEAR}\n"

  # print 1 of n files, sort order, filter etc details
  $title ||= Dir.pwd.sub(ENV['HOME'], '~')

  # Add bookmark next to name of dir, if exists
  bm = $bookmarks.key(Dir.pwd)
  bm = " ('#{bm})" if bm

  fin = $sta + $viewport.size
  fl = $view.size

  # fix count of entries so separator and enhanced entries don't show up
  if $enhanced_mode
    ix = $viewport.index SEPARATOR
    fin = $sta + ix if ix

    ix = $view.index SEPARATOR
    fl = ix if ix
  end

  t = fl.zero? ? "#{$title}#{bm}  No files." : "#{$title}#{bm}  #{$sta + 1} to #{fin} of #{fl}  #{$sorto} F:#{$filterstr}"

  # don't exceed columns while printing
  t = t[t.size - $gcols..-1] if t.size >= $gcols

  print "#{BOLD}#{t}#{CLEAR}\n"
  print "EMPTY" if fl.zero?
end
# ------------- end of print_title --------------------------------#

# TODO: clean this up and simplify it
# NOTE: earlier this was called on every key (up-arow down arrow, now only
# called when page changes, so we only put directory name)
def status_line
    # prompt
    v_mm = $mode ? "[#{$mode}] " : ''
    cf = current_file
    $message = ' | No matches. Press ESCAPE' if $patt && !cf

    clear_last_line

    # Print the filename at the right side of the status_line
    # sometimes due to search, there is no file
    if cf
      if @debug_flag
        # XXX this will not work on file basis FIXME
        print_debug_info cf
      else
        # print_on_right "#{Dir.pwd}"
        print_filename_status_line if @filename_status_line
      end
    end
    # move to beginning of line, reset text mode after printing
    # patt and message are together, no gap, why not ? 2019-04-08 -
    if $patt && $patt != ''
      patt = "[/#{$patt}]"
      patt[-1] = '/i]' if $ignorecase
    end
    # bring cursor to start of line
    # add background color
    # print mode
    # print search pattern if any
    # print message if any
    # print "\r#{v_mm}#{patt}#{$message}\e[m"
    print "\r\e[33;4#{$status_color}m#{v_mm}#{patt}#{$message}\e[m"

end

def print_debug_info cf=current_file()
  print_on_right "len:#{cf.length}/#{$temp_wid} = #{$sta},#{$cursor},#{$stact},#{$viewport.size},#{$grows} | #{cf}"
end

def print_filename_status_line cf=current_file()
  print_on_right "| #{cf}".rjust(40)
end

# should we do a read of the dir
def rescan?
  $rescan_required
end

def rescan_required flag=true
  $rescan_required = flag
  redraw_required if flag
end

def redraw flag=false
  read_directory if flag

  draw_directory
end

def draw_directory
  # all this seems to be happening for each keystroke even if
  # not really required. FIXME maybe reduce and call when required


  # view consists of all files (filtered by pattern if necessary)
  # viewport is only that subset of view that is displayed on screen
  create_viewport
  clear_screen
  print_title

  # add hint and format the line
  buff = format_array $viewport

  # break viewport into as many columns as required
  # This is where directories get their blue color
  buff = columnate buff, $grows

  # starts printing array on line 3
  buff.each { |line| print line, "\n" }
  print

  status_line

  # place cursor correctly, we will use this to highlight current row
end

# place cursor correctly, we will use this to highlight current row
# XXX i am not sure how to highlight the bg without rewriting the text.
# I can get the filename but it has been truncated.
# I can get the earlier filename but the color has to be determined again.
# FIXME flinks after paging
# FIXME color of original hint lost
def place_cursor
  # clear_cursor
  # hint = get_shortcut($cursor)
  c = $cursor - $sta
  if c < $grows
    # system "tput cup #{c + 2} 0"
    # print "\e[#{c + 3};0H"
    tput_cup c, 0
    # print "#{CURSOR_COLOR}#{hint} >#{CLEAR}"
    return
  end
  wid = get_width $viewport.size, $grows
  rows = c % $grows
  cols = (c / $grows) * wid
  # system "tput cup #{rows + 2} #{cols}"
  # print "\e[#{rows + 3};#{cols + 1}H"
  tput_cup rows, cols
  # print "#{CURSOR_COLOR}#{hint} >#{CLEAR}"
end

# clear the earlier position when we move.
# Currently not using until I can implement chgat here.
def clear_cursor
  return unless $old_cursor

  hint = get_shortcut($old_cursor)
  if $old_cursor < $grows
    # FIXME: faster way of getting here ? see fff
    # system "tput cup #{$old_cursor + 2} 0"
    tput_cup $old_cursor, 0
    # print "#{CURSOR_COLOR}#{hint} >#{CLEAR}"
    print "#{hint}  "
    return
  end
  wid = get_width $viewport.size, $grows
  rows = $old_cursor % $grows
  cols = ($old_cursor / $grows) * wid
  # system "tput cup #{rows + 2} #{cols}"
  tput_cup rows, cols
  # print "#{CURSOR_COLOR}#{hint} >#{CLEAR}"
  print "#{hint}  "
end

# place cursor on row and col taking first two rows into account
def tput_cup row, col
  # we add 3: 2 is for the help and directory line. 1 is since tput is 1 based
  print "\e[#{row + 3};#{col + 1}H"
end

def redraw_required(flag=true) $redraw_required = flag; end

def resolve_key key
  ret = true
  if key.match?(/^[a-pr-zZ]$/)
    # hint mode
    ret = select_hint $viewport, key
  elsif key == 'BACKSPACE'
    # do we really need this TODO
    $patt = $patt[0..-2] if $patt && !$patt.empty?
    $message = $patt = nil if $patt == ''
  elsif '0123456789'.include? key
    resolve_numeric_key key
  else
    resolve_binding key
  end
  ret
end

def resolve_binding key
  # fetch binding for key
  x = $bindings[key]

  # remove comment string so only binding is left
  x, _ = x.split(':') if x

  # split into binding and args
  x = x.split if x
  if x
    binding = x.shift
    args = x
    send(binding, *args) if binding
  else
    # perror "No binding for #{key}"
  end
end

# numbers represent quick bookmarks
# if bookmark exists, go to else create it.
def resolve_numeric_key key
  d = $bookmarks[key]
  if d
    change_dir d
    return
  end

  set_bookmark key
  message "Created bookmark #{key}."
end

def set_bookmark key, dir=Dir.pwd
  $bookmarks[key] = dir
end

## write current dir to a file so we can ccd to it when exiting
def write_curdir
  f = File.expand_path('~/.fff_d')
  s = Dir.pwd
  File.open(f, 'w') do |f2|
    f2.puts s
  end
  # puts "Written #{s} to #{f}"
end

## code related to long listing of files
GIGA_SIZE = 1_073_741_824.0
MEGA_SIZE = 1_048_576.0
KILO_SIZE = 1024.0

# Return the file size with a readable style.
# NOTE format is a kernel method.
def readable_file_size(size, precision)
  if size < KILO_SIZE then format('%d B', size)
  elsif size < MEGA_SIZE then format("%.#{precision}f K", (size / KILO_SIZE))
  elsif size < GIGA_SIZE then format("%.#{precision}f M", (size / MEGA_SIZE))
  else format("%.#{precision}f G", (size / GIGA_SIZE))
  end
end

## format date for file given stat
def date_format(t)
  t.strftime '%Y/%m/%d'
end

##
#
# print in columns
# ary - array of data (viewport, not view)
# siz  - how many lines should there be in one column
#
def columnate ary, siz
  buff = []
  return buff if ary.nil? || ary.empty?

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  wid = get_width ary.size, siz
  $temp_wid = wid

  # ix refers to the index in the complete file list, wherease we only show 60 at a time
  ix = 0
  loop do
    ## ctr refers to the index in the column
    #  siz is how many items in one column
    ctr = 0
    while ctr < siz

      f = ary[ix]
      # f is not just filename but marker and hint

      # check to see if we need to truncate
      # 2019-03-18 - truncate from middle of string.
      # 2019-03-24 - truncate and size to take care of color codes
      # fsz = f.size
      unformatted_len, _ = filename_len(f)
      if unformatted_len > wid
        # take the excess out from the center on both sides
        f = truncate_formatted_filename(f, unformatted_len, wid)


      elsif unformatted_len < wid

        # f = f.ljust(wid)
        f << ' ' * (wid - unformatted_len)

      end

      # if already a value in that line, append to it
      if buff[ctr]
        buff[ctr] += f
      else
        buff[ctr] = f
      end

      ctr += 1
      ix += 1
      break if ix >= ary.size
    end
    break if ix >= ary.size
  end
  buff
end

# shorten the filename to wid
# unformatted_len is the length without ANSI formatting
# wid is the exact width every line should restrict itself to.
# f is filename with hint and space and possible ANSI codes.
# WARN: check for hint getting swallowed in case of 5 columns
def truncate_formatted_filename f, unformatted_len, wid
  excess = unformatted_len - wid

  f = case @truncate_from

      when :right
        # text starts at 0, or 'm' if escape code
        sindex = f[0] == "\e" ? f.index('m') : 0

        # We show exactly `wid` characters, but escapes are not displayed
        # so add that may characters
        # Also, remove 2 for $ and space
        f[0..wid + sindex - 2] + "$ \e[m"

      when :center

        # from central point calculate how much to remove in both directions
        center = unformatted_len / 2
        excess_half = excess / 2
        point = center + excess_half
        point1 = point - excess

        # remove text between point1 and point
        f[0..(point1 - 1)] + '$' + f[point + 2..-1] + ' '

      when :left

        # NOTE: we cannot remove the hint
        # for single hints we need to add extra space
        # there could be escape codes of varying length
        sindex = f.index ' '
        # if f[0] == "\e"
          # mindex = f.index('m')
          # hintsize = sindex - mindex - 1
        # else
          # hintsize = sindex - 1
        # end
        # f[0..sindex + 1] + '<' + f[-wid + hintsize..-1] + ' '
        # @log.debug "XXX #{excess}: #{f} / #{wid}"
        # 4 = 2 for literals, 2 to get ahead of sindex+1
        f[0..sindex + 1] + '<' + f[sindex + 4 + excess..-1] + ' '
        # in some cases 29/32 we are actually overlapping 2 parts above
        #  same for 34/32
      end
  return f
end

def get_width arysz, siz
  ars = [$pagesize, arysz].min
  d = 0
  return $gcols - d if ars <= siz

  tmp = (ars * 1.000 / siz).ceil
  wid = $gcols / tmp - d
  wid
end

# calculate length of filename without ANSI color codes
def filename_len name
  l = name.length
  return l if name[0] != "\e"

  # we have an escape code at the start of the name (and end, too)
  index = name.index('m')
  eindex = name.rindex("\e")
  reall = eindex - index - 1
  return reall, l
end

## formats the data with number, mark and details
def format_array(ary)
  # buff = Array.new
  buff = Array.new(ary.size)
  return buff if ary.nil? || ary.empty?

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  # ix refers to the index in the complete file list, whereas we only
  # show 60 at a time
  ix = 0
  ctr = 0
  ary.each do |f|
    ## ctr refers to the index in the column
    mark = SPACE
    cur = SPACE
    ind = get_shortcut(ix)


    # Handle separator before enhanced file list.
    # We do lost a shortcut
    if f == SEPARATOR
      ind = cur = mark = '-'
    end

    mark = '+' if visited? f
    # cur = CURMARK if ix + $sta == $cursor # 2019-03-29 - removed reduced calls
    # NOTE seems like f and ary[ix] are the same
    mark = GMARK if selected?(ary[ix])

    # take care of shortcuts in visited files and dirs
    fullname = f[0] == '~' ? File.expand_path(f) : f
    color = color_for fullname

    if $long_listing
      begin
        if File.exist? f
          stat = File.stat(f)
        else
          # dead link
          if File.symlink?(f)
            stat = File.lstat(f)
          else
            # remove last character and get stat
            last = f[-1]
            stat = File.stat(f.chop) if last == ' ' || last == '@' || last == '*'
          end
        end
        # this is for saved directories etc which are shortened
        stat ||= File.stat(File.expand_path(f))
        f = format('%10s  %s  %s', readable_file_size(stat.size, 1),
                   date_format(stat.mtime), f)
      rescue StandardError => e
        @log.warn "WARN::#{e}: FILE:: #{f}"
        f = format('%10s  %s  %s', '?', '??????????', f)
      end
    end

    # 2019-03-31 - replace unprintable chars with ?
    f = f.gsub(/[^[:print:]]/, '?')

    s = "#{ind}#{mark}#{cur}#{f}"
    if color
      s = "#{color}#{s}#{CLEAR}"
    end

    buff[ctr] = s

    ctr += 1
    ix += 1
  end
  buff
end

# determine color for a filename based on extension, then pattern, then filetype
def color_for fname
  extension = File.extname(fname)
  color = $ls_color[extension]
  return color if color

  # check file against patterns
  if File.file?(fname)
    $ls_pattern.each_pair do |k, v|
      # if fname.match?(/k/)
      if fname =~ /#{k}/
        # @log.debug "#{fname} matched #{k}. color is #{v[1..-2]}"
        return v
      # else
        # @log.debug "#{fname} di not match #{k}. color is #{v[1..-2]}"
      end
    end
  end

  # check filetypes
  if File.exist? fname
    # @log.debug "Filetype:#{File.ftype(fname)}"

    return $ls_ftype[File.ftype(fname)] if $ls_ftype.key? File.ftype(fname)
    return $ls_ftype['ex'] if File.executable?(fname)
  else
    # orphan file, but fff uses mi
    return $ls_ftype['mi'] if File.symlink?(fname)

    @log.warn "FILE WRONG: #{fname}"
    return $ls_ftype['or']
  end

  nil
end

def parse_ls_colors

  colorvar = ENV['LS_COLORS']
  if colorvar.nil?
    $ls_colors_found = nil
    return
  end
  $ls_colors_found = true
  ls = colorvar.split(':')
  ls.each do |e|
    patt, colr = e.split '='
    colr = "\e[" + colr + 'm'
    if e.start_with? '*.'
      # extension, avoid '*' and use the rest as key
      $ls_color[patt[1..-1]] = colr
      # @log.debug "COLOR: Writing extension (#{patt})."
    elsif e[0] == '*'
      # file pattern, this would be a glob pattern not regex
      # only for files not directories
      patt = patt.gsub('.', '\.')
      patt = patt.sub('+', '\\\+') # if i put a plus it does not go at all
      patt = patt.gsub('-', '\-')
      patt = patt.gsub('?', '.')
      patt = patt.gsub('*', '.*')
      patt = "^#{patt}" if patt[0] != '.'
      patt = "#{patt}$" if patt[-1] != '*'
      $ls_pattern[patt] = colr
      # @log.debug "COLOR: Writing file (#{patt})."
    elsif patt.length == 2
      # file type, needs to be mapped to what ruby will return
      # file, directory di, characterSpecial cd, blockSpecial bd, fifo pi, link ln, socket so, or unknown
      # di = directory
      # fi = file
      # ln = symbolic link
      # pi = fifo file
      # so = socket file
      # bd = block (buffered) special file
      # cd = character (unbuffered) special file
      # or = symbolic link pointing to a non-existent file (orphan)
      # mi = non-existent file pointed to by a symbolic link (visible when you type ls -l)
      # ex = file which is executable (ie. has 'x' set in permissions).
      case patt
      when 'di'
        $ls_ftype['directory'] = colr
      when 'cd'
        $ls_ftype['characterSpecial'] = colr
      when 'bd'
        $ls_ftype['blockSpecial'] = colr
      when 'pi'
        $ls_ftype['fifo'] = colr
      when 'ln'
        $ls_ftype['link'] = colr
      when 'so'
        $ls_ftype['socket'] = colr
      else
        $ls_ftype[patt] = colr
      end
      # @log.debug "COLOR: ftype #{patt}"
    end
  end
end

## select file based on key pressed
def select_hint view, key

  ix = get_index(key, view.size)
  return nil unless ix

  f = view[ix]
  return nil unless f
  return nil if f == SEPARATOR

  $cursor = $sta + ix

  if $mode == 'SEL'
    toggle_select f
  elsif $mode == 'COM'
    run_command f
  else
    open_file f
  end
  true
end

## toggle selection state of file
def toggle_select f=current_file
  if selected? f
    remove_from_selection f
  else
    $selected_files.clear if $selection_mode == 1
    add_to_selection f
  end
  message "#{$selected_files.count} files selected.   "
  # XXX is it possible to just redraw this line
  redraw_required
end

## open file or directory
def open_file(f)
  return unless f

  f = File.expand_path(f) if f[0] == '~'
  unless File.exist? f
    # this happens if we use (T) in place of (M)
    # it places a space after normal files and @ and * which borks commands
    last = f[-1]
    f = f.chop if last == ' ' || last == '@' || last == '*'
  end

  # could be a bookmark with position attached to it
  f, _nextpos = f.split(':') if f.index(':')
  if File.directory? f
    save_dir_pos
    change_dir f #, nextpos
  elsif File.readable? f
    # TODO: looks complex pls simplify !! XXX
    # by default, default command is nil. Changed in toggle_pager_mode
    $default_command ||= '$PAGER'
    # by default mode, is false, changed in toggle_pager_mode
    # Get filetype, and check for command for type, else extn else unknown
    if !$editor_mode
      ft = filetype f
      comm = $pager_command[ft] if ft
      comm ||= $pager_command[File.extname(f)]
      comm ||= $pager_command['unknown']
    else
      # 2019-04-10 - what does this mean, that in editor_mode, editor
      # opens everything? what of images etc
      # TODO use editor only for text, otherwise use filetype or another hash
      # like editor_command
      comm = $default_command
    end
    comm ||= $default_command
    # '%%' will be substituted with the filename. See zip
    comm = if comm.index('%%')
             comm.gsub('%%', Shellwords.escape(f))
           else
             comm + " #{Shellwords.escape(f)}"
           end
    clear_screen
    reset_terminal
    system(comm.to_s)
    setup_terminal
    # XXX maybe use absolute_path instead of hardcoding
    f = Dir.pwd + '/' + f if f[0] != '/'
    $visited_files.insert(0, f)
    push_used_dirs Dir.pwd
  else
    perror "open_file: (#{f}) not found"
    # could check home dir or CDPATH env variable DO
  end
  redraw_required
end

# regardless of mode, view the current file using pager
def page_current
  command = ENV['MANPAGER'] || ENV['PAGER'] || 'less'
  run_on_current command
end

# regardless of mode, edit the current file using editor
def edit_current
  command = ENV['EDITOR'] || ENV['VISUAL'] || 'vim'
  run_on_current command
  $visited_files.insert(0, current_file)
end

def open_current
  opener = /darwin/ =~ RUBY_PLATFORM ? 'open' : 'xdg-open'
  run_on_current opener
  $visited_files.insert(0, current_file)
end

# run given command on current file
def run_on_current(command)
  f = current_file
  return unless f
  f = File.expand_path(f)
  return unless File.readable?(f)

  clear_screen
  reset_terminal
  comm = "#{command} #{f}"
  system(comm.to_s)
  push_used_dirs
  setup_terminal
end

## run command on given file/s
#   Accepts command from user
#   After putting readline in place of gets, pressing a C-c has a delayed effect.
#   It goes into exception block after executing other commands and still
#   does not do the return !
def run_command(f)
  files = nil
  case f
  when Array
    # escape the contents and create a string
    files = Shellwords.join(f)
  when String
    files = Shellwords.escape(f)
  end
  begin
    # Readline::HISTORY.push(*values)
    command = readline "Run a command on #{files}: "
    # command = gets().chomp
    return if command.empty?

    # command2 = gets().chomp
    command2 = readline 'Second part of command: '
    puts "#{command} #{files} #{command2}"
    system "#{command} #{files} #{command2}"
    setup_terminal
  rescue StandardError => ex
    perror "Canceled command, (#{ex}) press a key"
    return
  end

  refresh
  puts 'Press a key ...'
  push_used_dirs Dir.pwd
  get_char
end

## cd to a dir.
def change_dir f
  unless File.directory? f
    perror "#{f} is not a directory, or does not exist."
    return
  end

  # before leaving a dir we save it in the list, as well as the cursor
  # position, so we can restore that position when we return
  $visited_dirs.insert(0, Dir.pwd)
  save_dir_pos

  f = File.expand_path(f)
  Dir.chdir f
  read_directory
  post_cd

  redraw_required
end

def goto_previous_dir
  prev_dir = $visited_dirs.first
  return unless prev_dir
  change_dir prev_dir
end

def index_of dir
  $files.index(dir)
end

## clear sort order and refresh listing, used typically if you are in some view
#  such as visited dirs or files
def escape
  $sorto = nil
  $sorto = $default_sort_order
  $viewctr = 0
  $title = nil
  $filterstr = 'M'
  $message = nil
  visual_block_clear
  refresh
end

## refresh listing after some change like option change, or toggle
def refresh
  $patt = nil
  $title = nil
  rescan_required
end

# put directories first, then files
def group_directories_first files
  dirs = files.select { |f| File.directory?(f) }
  # earlier I had File? which removed links, esp dead ones
  fi   = files.select { |f| !File.directory?(f) }
  dirs + fi
end

## unselect all files
def unselect_all
  $selected_files = []
  $visual_mode = nil
end

## select all files
def select_all
  dir = Dir.pwd
  $selected_files = $view.map { |file| File.join(dir, file) }
end

## accept dir to goto and change to that ( can be a file too)
def goto_dir
  # print "\e[?25h"
  # print_last_line 'Enter path: '
  begin
    # path = gets.chomp
    path = readline 'Enter path to go to: '
    if path.nil? || path == ''
      clear_last_line
      return
    end
    # rescue => ex
  rescue StandardError => ex
    # Nope, already caught interrupt and sent back nil
    perror 'Cancelled cd, press a key'
    return
  ensure
    # print "\e[?25l"
  end
  f = File.expand_path(path)
  unless File.directory? f
    ## check for env variable
    tmp = ENV[path]
    if tmp.nil? || !File.directory?(tmp)
      ## check for dir in home
      tmp = File.expand_path("~/#{path}")
      f = tmp if File.directory? tmp
    else
      f = tmp
    end
  end

  open_file f
end

## toggle mode to selection or not
#  In selection, pressed hotkey selects a file without opening, one can keep selecting
#  (or deselecting).
#
def toggle_selection_mode
  if $mode == 'SEL'
    $selection_mode = 1
    unselect_all
    $mode = nil
    message 'Selection mode is single.   '
  else
    $selection_mode = 2
    $mode = 'SEL'
    message 'Typing a hint selects the file. Typing again will clear   .  '
  end
end

# go to parent dir, and maintain cursor on the dir we came out of
def goto_parent_dir
  # When changing to parent, we need to keep cursor on
  #  parent dir, not first
  curr = File.basename(Dir.pwd)

  return if curr == '/'

  change_dir '..'

  return if curr == Dir.pwd

  # get index of child dir in this dir, and set cursor to it.
  index = $files.index(curr + '/')
  pause "WARNING: Could not find #{curr} in this directory." unless index
  $cursor = index if index
end

def goto_home_dir
  change_dir '~'
end


# Goes to directory bookmarked with number or upper case char.
# If lower case character given, then go to first file starting with char.
def goto_bookmark key=nil
  unless key
    clear_last_line
    print 'Enter bookmark char: '
    key = get_char
  end
  d = $bookmarks[key]
  if d
    change_dir d
  else
    perror "#{key} not a bookmark. "
  end
end

## take regex from user, to run on files on screen, user can filter file names
def enter_regex
  # print 'Enter (regex) pattern: '
  # move to beginning of line, and clear till EOL
  # print "\r\e[K"
  $patt = readline '/'
end

# page/scroll down.
def next_page
  $sta += $pagesize
  $cursor += $pagesize
  $sta = $cursor if $sta > $cursor
  $stact = 0
  $old_cursor = nil
  redraw_required
end

def prev_page
  $sta -= $pagesize
  $cursor -= $pagesize
  $old_cursor = nil
  # FIXME: check cursor sanity and if not changed then no redraw
  redraw_required
end

def print_help
  page_with_tempfile do |file|
    file.puts '    HELP'

    file.puts
    file.puts 'To open a file or dir press 1-9 a-z A-Z (on left of file)'
    file.puts 'Ctrl-s to select file under cursor'
    file.puts 'Selection Mode: Each selection adds to selection list (toggles)'
    file.puts '   Execute commands on selected files. e.g D C-x   '
    file.puts '   Upon exiting mode, selection is cleared'
    file.puts 'Use left and right arrows to move through directories'
    file.puts
    ary = []
    # 2019-03-19 -  if : then show text after colon
    $bindings.each_pair { |k, v|
      vv = v.tr('_', ' ')
      vv = vv.split(':')[1].strip if vv.include?(':')
      ary.push "#{k.ljust(7)}  =>  #{vv}"
    }
    # FIXME this works but not properly when long_listing is true.
    # We should avoid using columnate as there are several file related things.
    ary = columnate ary, (ary.size/2)+1
    ary.each { |line| file.puts line }
  end
end

def page_stat_for_file
  stat = %x[ stat #{current_file} ]
  return unless stat

  page_with_tempfile do |file|
    file.puts stat
  end

end

def page_with_tempfile
  require 'tempfile'
  file = Tempfile.new('cetus')
  begin
    yield file
    file.flush
    system "$PAGER #{file.path}"
    setup_terminal
  rescue StandardError
    file.close
    file.unlink
  end
end

def debug_vars
  page_with_tempfile do |file|
    file.puts "DEBUG VARIABLES for #{current_file}:"
    file.puts
    file.puts "sta    #{$sta}"
    file.puts "cursor #{$cursor}"
    file.puts "stact  #{$stact}"
    file.puts "viewport.size  #{$viewport.size}"
    file.puts "pagesize       #{$pagesize}"
    file.puts "view.size      #{$view.size}"
    file.puts "grows          #{$grows}"
    file.puts "file   #{current_file}"
    file.puts
    file.puts `file "#{current_file}"`
    file.puts
    file.puts %x[stat   "#{current_file}"]
  end
  redraw_required
end

def view_bookmarks
  clear_last_line
  puts 'Bookmarks: '
  $bookmarks.each_pair { |k, v| puts "#{k.ljust(7)}  =>  #{v}" }
  puts
  print 'Enter bookmark to goto: '
  key = get_char
  goto_bookmark(key)
end

# MENU MAIN
def main_menu
  h = {
    :a => :ag,
    '/' => :ffind,
    :l => :locate,
    :v => :vidir,
    :z => :z_interface,
    :d => :child_dirs,
    :r => :recent_files,
    '1' => :select_from_visited_files,
    '2' => :select_from_used_dirs,
    :t => :dirtree,
    '4' => :tree,
    :o => :order_menu,
    :F => :filter_menu,
    :c => :create_menu,
    :b => :bookmark_menu,
    :s => :selection_menu,
    :x => :extras
  }
  menu 'Main Menu', h
end

def selection_menu
  h = {
    :a => :select_all,
    :u => :unselect_all,
    :s => :toggle_select,
    '*' => 'toggle_selection_mode',
    'x' => 'visual_mode_toggle',
    :v => :view_selected_files
  }
  menu 'Selection Menu', h
end

def bookmark_menu
  h = {
    v: :view_bookmarks,
    c: :create_bookmark,
    g: :goto_bookmark
  }
  menu 'Bookmark Menu', h
end

# Create a menu using title, and hash of key and binding
def menu title, h
  return unless h

  clear_last_line # 2019-03-30 - required since cursor is not longer at bottom
  pbold title.to_s
  # h.each_pair { |k, v| puts " #{k}: #{v}" }
  # 2019-03-09 - trying out using `column` to print in cols
  ary = []

  # 2019-04-07 - check $bindings for shortcut and get key, add global
  #  binding in brackets
  h.each_pair do |k, v|

    # get global binding
    scut = $bindings.key(v.to_s)
    scut = " (#{scut})" if scut

    ary << " #{k}: #{v} #{scut}"
  end
  x = ary.join("\n")
  puts %x{echo "#{x}" | column}

  key = get_char
  binding = h[key]
  binding ||= h[key.to_sym]
  # TODO: 2019-03-21 - menu's do not have comments, they are symbols
  # binding, _ = binding.split(':')
  if binding
    send(binding) if respond_to?(binding, true)
  end
  redraw_required
  [key, binding]
end

def toggle_menu
  h = { h: :toggle_hidden,
        c: :toggle_case,
        l: :toggle_long_list,
        '1' => :toggle_columns,
        d: :toggle_group_dirs,
        :p => :toggle_pager_mode,
        :D => :toggle_debug_flag,
        '8' => :toggle_selection_mode,
        '*' => :toggle_selection_mode,
        v: :visual_mode_toggle,
        t: :toggle_truncate_from,
        e: :toggle_enhanced_list
  }

  _, menu_text = menu 'Toggle Menu', h
  return unless menu_text

  case menu_text
  when :toggle_hidden
    # NOTE: now that I am shifting queries to ruby not sure this will continue
    # FNM_DOTMATCH
    #  working everywhere
    # zsh D - dot files should show
    $hidden = $hidden ? nil : 'D'
    message "Show hidden is now #{!$hidden.nil?}"
    rescan_required
  when :toggle_case
    $ignorecase = !$ignorecase
    message "Ignore Case is now #{$ignorecase}"
    rescan_required
  when :toggle_group_dirs
    @group_dirs = !@group_dirs
    message "Group Dirs First is now #{@group_dirs}"
    rescan_required
  when :toggle_columns
    if $gviscols == 1
      $gviscols = 3
    else
      $gviscols = 1
    end
    # $long_listing = false if $gviscols > 1
    x = $grows * $gviscols
    $pagesize = $pagesize == x ? $grows : x
    message "Visible columns now set to #{$gviscols}"
    rescan_required
  when :toggle_pager_mode
    $editor_mode = !$editor_mode
    $default_command = if $editor_mode
                         ENV['EDITOR'] # earlier nil # 2019-03-10 -
                         # it was nil so we could set a default command
                       else
                         ENV['MANPAGER'] || ENV['PAGER']
                       end
    message "Default command is #{$default_command}"
  when :toggle_enhanced_list
    $enhanced_mode = !$enhanced_mode
    message "Enhanced mode is #{$enhanced_mode}"
    rescan_required

  when :toggle_long_list
    $long_listing = !$long_listing
    if $long_listing
      $saved_gviscols = $gviscols
      $gviscols = 1
      $pagesize = $grows
    else
      $gviscols = $saved_gviscols || 3
      x = $grows * $gviscols
      $pagesize = $pagesize == x ? $grows : x
    end
    if $stact > 0
      $sta = $stact
      $stact = 0 # in case user was panned 2019-03-20 -
    end
    message "Long listing is #{$long_listing}, vis cols is #{$gviscols}"
    rescan_required
  when :toggle_debug_flag
    @debug_flag = !@debug_flag
    message "Debug flag is #{@debug_flag}"

  when :toggle_truncate_from
    # if filename exceeds width cut from which direction
    @truncate_from = case @truncate_from
                     when :center
                       :left
                     when :left
                       :right
                     when :right
                       :center
                     else
                       :center
                     end
    message "Truncate long filenames from: #{@truncate_from}"
  end
end

def order_menu
  # zsh o = order, O = reverse order
  # ruby mtime/atime/ctime come reversed so we have to change o to O
  lo = nil
  h = { m: :modified, a: :accessed, M: :oldest,
        s: :largest, S: :smallest, n: :name, N: :rev_name,
        # d: :dirs,
        c: :inode,
        x: :extension,
        z: :clear }
  _, menu_text = menu 'Sort Menu', h
  case menu_text
  when :modified
    lo = 'Om'
  when :accessed
    lo = 'Oa'
  when :inode
    lo = 'Oc'
  when :oldest
    lo = 'om'
  when :largest
    lo = 'OL'
  when :smallest
    lo = 'oL'
  when :name
    lo = 'on'
  when :extension
    lo = 'ox'
  when :rev_name
    lo = 'On'
  when :dirs
    lo = '/'
  when :clear
    lo = ''
  end
  ## This needs to persist and be a part of all listings, put in change_dir.
  $sorto = lo
  message "Sorted on #{menu_text}"
  rescan_required
end

def create_menu
  h = { f: :create_a_file,
        d: :create_a_dir,
        b: :create_bookmark
  }
  _, menu_text = menu 'Create Menu', h
end

# thse need to be placed in correct position, some do nothing
#  and some like ffind have no menu item
# TODO FIXME uncalled now. look into this
def command_menu
  #  since these involve full paths, we need more space, like only one column
  ## in these cases, getting back to the earlier dir, back to earlier listing
  # since we've basically overlaid the old listing
  # should be able to sort THIS listing and not rerun command. But for that I'd need to use
  # xargs ls -t etc rather than the zsh sort order. But we can run a filter using |.
  #
  h = { t: :today, D: :default_command, R: :remove_from_list,
        v: :view_selected_files }
  h[:e] = if $editor_mode
            :pager_mode
          else
            :editor_mode
          end
  _, menu_text = menu 'Command Menu', h
  case menu_text
  when :pager_mode
    $editor_mode = false
    $default_command = ENV['MANPAGER'] || ENV['PAGER']
  when :editor_mode
    $editor_mode = true
    $default_command = nil
  when :ffind
    ffind
  when :locate
    locate
  when :today
    # zshglob: M = MARK_DIRS with slash
    # zshglob: 'm0' 'm' = modified time, '0' = 0 days ago
    $files = `zsh -c 'print -rl -- *(#{$hidden}Mm0)'`.split("\n")
    $title = "Today's files"
  when :default_command
    puts ' This no longer works'
    puts 'Selecting a file usually invokes $EDITOR'
    puts 'What command do you want to use repeatedly on selected files: '
    $default_command = gets.chomp
    if $default_command != ''
      print 'Second part of command (maybe blank): '
      $default_command2 = gets.chomp
    else
      print 'Cleared default command, will default to $EDITOR'
      $default_command2 = nil
      $default_command = nil
    end
  end
  # redraw
end

# This is quite badly placed and named. Maybe these should go elsewhere
def extras
  h = { '1' => :one_column,
        '2' => :multi_column,
        :c => :columns,
        s: :scripts,
        g: :generators,
        :B => :bindkey_ext_command,
        :r => :config_read,
        :w => :config_write
  }
  key, menu_text = menu 'Extras Menu', h
  case menu_text
  when :one_column
    $pagesize = $grows
  when :multi_column
    # $pagesize = 60
    $pagesize = $grows * $gviscols
  when :columns
    print "How many columns to show: 1-6 [current #{$gviscols}]? "
    key = get_char
    key = key.to_i
    if key > 0 && key < 7
      $gviscols = key.to_i
      $pagesize = $grows * $gviscols
    end
  end
end

def filter_menu
  h = { :d => :dirs, :f => :files, :e => :emptydirs, '0' => :emptyfiles,
  :r => :reduce_list, :x => :extension}
  _, menu_text = menu 'Filter Menu', h
  files = nil
  case menu_text
  when :dirs
    $filterstr = '/M'
    # zsh /M MARK_DIRS appends trailing '/' to directories
    files = `zsh -c 'print -rl -- *(#{$sorto}/M)'`.split("\n")
    $title = 'Filter: directories only'
  when :files
    $filterstr = '.'
    # zsh '.' for files, '/' for dirs
    files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}.)'`.split("\n")
    $title = 'Filter: files only'
  when :emptydirs
    $filterstr = '/D^F'
    # zsh F = full dirs, ^F empty dirs
    files = `zsh -c 'print -rl -- *(#{$sorto}/D^F)'`.split("\n")
    $title = 'Filter: empty directories'
  when :emptyfiles
    $filterstr = '.L0'
    # zsh .L size in bytes
    files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}.L0)'`.split("\n")
    $title = 'Filter: empty files'
  when :reduce_list
    files = reduce
  when :extension
    files = filter_for_current_extension
  end
  if files && files.count > 0
    $files = files
    $stact = 0
    $message = "Filtered on #{menu_text}. Press ESC to return."
    # redraw
  else
    perror 'Sorry, No files. '
    $title = nil
  end
end

def reduce pattern=nil
  unless pattern
    last_line 'Enter a pattern to reduce current list: '
    pattern = gets.chomp
  end
  $title = "Filter: pattern #{pattern}"
  $files = $files.select { |f| f.match(pattern) }
end

def filter_for_current_extension
  extn = File.extname(current_file)
  return unless extn

  $files = $files.select { |f| !File.directory?(f) && extn == File.extname(f) }
end

def select_from_used_dirs
  $title = 'Used Directories'
  home = File.expand_path '~'
  $files = $used_dirs.uniq.map { |path| path.sub("#{home}", '~') }
  # redraw
end

def select_from_visited_files
  # not yet a unique list, needs to be unique and have latest pushed to top
  $title = 'Visited Files'
  home = File.expand_path '~'
  $files = $visited_files.uniq.map { |path| path.sub("#{home}", '~') }
  # redraw
end

# maybe unused ??? XXX
def select_bookmarks
  $title = 'Bookmarks'
  $files = $bookmarks.values
end

## part copied and changed from change_dir since we don't dir going back on top
#  or we'll be stuck in a cycle
def pop_dir
  # the first time we pop, we need to put the current on stack
  $visited_dirs.push Dir.pwd unless $visited_dirs.index(Dir.pwd)
  ## XXX make sure thre is something to pop
  d = $visited_dirs.delete_at 0
  ## XXX make sure the dir exists, cuold have been deleted. can be an error or crash otherwise
  $visited_dirs.push d
  Dir.chdir d
  post_cd
  rescan_required
end

# after changing directory
def post_cd
  $title = $patt = $message = nil
  $sta = $cursor = $stact = 0
  $visual_block_start = nil
  $current_dir = Dir.pwd
  screen_settings

  # goto last position cursor was in this dir
  revert_dir_pos
end

## read dirs and files and bookmarks from file
def config_read
  f = File.expand_path(CONFIG_FILE)
  return unless File.readable? f

  hash = loadYML(f)
  $used_dirs = hash['DIRS']
  $visited_files = hash['FILES']
  $bookmarks = hash['BOOKMARKS']
  $used_dirs.concat get_env_paths
end

def get_env_paths
  files = []
  %w[GEM_HOME PYTHONHOME].each do |p|
    d = ENV[p]
    files.push d if d
  end
  %w[RUBYLIB RUBYPATH GEM_PATH PYTHONPATH].each do |p|
    d = ENV[p]
    files.concat d.split(':') if d
  end
  files
end

## save dirs and files and bookmarks to a file
# - moved to yml 2019-03-09
def config_write
  # Putting it in a format that zfm can also read and write
  f1 = File.expand_path(CONFIG_FILE)
  hash = {}
  hash['DIRS'] = $used_dirs.select {|dir| File.exist? dir}
  hash['FILES'] = $visited_files.select {|file| File.exist? file}
  # NOTE bookmarks is a hash and contains FILE:cursor_pos
  hash['BOOKMARKS'] = $bookmarks #.select {|file| File.exist? file}
  writeYML hash, f1
  $writing = $modified = false
  message "Saved #{f1}"
end

# {{{ YML
require 'yaml'
def loadYML( filename)
  hash = YAML::load( File.open( filename ) )
  if $opt_debug
    $stderr.puts hash.keys.size
  end
  return hash
end
def writeYML obj, filename
  File.open(filename, 'w') {|f| f.write obj.to_yaml }
  if $opt_debug
    $stderr.puts "Written to file #{filename}"
  end
end
# }}}

## accept a character to save this dir as a bookmark
def create_bookmark

  clear_last_line
  print 'Enter A-Z, a-z or 0-9 to create a bookmark: '
  # print "\e[?25h" # unhide cursor
  key = get_char
  # print "\e[?25l" # hide cursor
  if key =~ /^[0-9A-Za-z]$/
    # $bookmarks[key] = "#{Dir.pwd}:#{$cursor}"
    set_bookmark key
    $modified = true
    message "Created bookmark #{key} for #{File.basename(Dir.pwd)}."
  else
    perror 'Bookmark must be alpha character or number.'
  end
  # redraw
end

# allow user to exit using :q :wq :x
# Was this supposed to be augmented, or just remain limited like this
# We should be able to do everything in the menus from here. TODO
def subcommand
  last_line
  print 'Enter command: q x wq p w e r h '
  begin
    command = readline
    return if command == ''
  rescue StandardError
    return
  end
  if command == 'q'
    # FIXME: 2019-03-22 - should this not call quit_command ?
    if $modified
      last_line
      print 'Do you want to save bookmarks? (y/n): '
      key = get_char
      if key == 'y'
        $writing = true
        $quitting = true
      elsif key == 'n'
        $quitting = true
        print 'Quitting without saving bookmarks'
      else
        perror 'No action taken.'
      end
    else
      $quitting = true
    end
  elsif command == 'wq'
    $quitting = true
    $writing = true
  elsif command == 'w'
    config_write
  elsif command == 'x'
    $quitting = true
    $writing = true if $modified
  elsif command == 'e'
    edit_current
  elsif command == 'o'
    open_current
  elsif command == 'h' or command == 'help' or command == '?'
    print_help
  elsif command == 'p'
    system 'echo $PWD | pbcopy'
    puts 'Stored PWD in clipboard (using pbcopy)'
  else
    perror "Don't know about command #{command}. Try :h or :help"
  end
  # redraw
end

def quit_command
  if $modified
    last_line
    puts 'Press y to save bookmarks before quitting ' if $modified
    print 'Press n to quit without saving'
    key = get_char
  else
    $quitting = true
  end
  $quitting = true if key == 'n'
  $quitting = $writing = true if key == 'y'
end

def views
  views = %w[/ om oa Om OL oL On on]
  viewlabels = %w[Dirs Newest Accessed Oldest Largest Smallest Reverse Name]
  $sorto = views[$viewctr]
  $title = viewlabels[$viewctr]
  $viewctr += 1
  $viewctr = 0 if $viewctr > views.size

  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}M)'`.split("\n")
  # redraw
end

def child_dirs
  $title = 'Directories in current directory'
  # M is MARK_DIRS option for putting trailing slash after dir
  # $files = `zsh -c 'print -rl -- *(/#{$sorto}#{$hidden}M)'`.split("\n")
  $files = dirs
  message "#{$files.size} directories."
  # redraw
end

def dirs dir='*'
  files = Dir.glob(dir, File::FNM_DOTMATCH).select {|f| File.directory?(f)} - %w[ . ..]
  files = add_slash files
  files
end

def add_slash files
  return files.map do |f|
    File.directory?(f) ? f + '/' : f
  end
end

def dirtree
  $title = 'Child directories recursive'
  # zsh **/ is recursive
  files1 = `zsh -c 'print -rl -- **/*(/#{$sorto}#{$hidden}M)'`.split("\n")
  $files = Dir['**/']
  @log.debug "zsh #{files1} != rb #{$files}" if files1 != $files
  message "#{$files.size} files."
  # redraw
end

#
# Get a full recursive listing of what's in this dir - useful for small projects with more
# structure than files.
def tree
  # Caution: use only for small projects, don't use in root.
  $title = 'Full Tree'
  # $files = `zsh -c 'print -rl -- **/*(#{$sorto}#{$hidden}M)'`.split("\n")
  $files = Dir['**/*']
  message "#{$files.size} files."
  # redraw
end

# lists recent files in current dir
# In some cases it shows mostly .git files, we need to prune those
def recent_files
  # print -rl -- **/*(Dom[1,10])
  $title = 'Recent files'
  # zsh D DOT_GLOB, show dot files
  # zsh om order on modification time
  $files = `zsh -c 'print -rl -- **/*(Dom[1,15])'`.split("\n").reject {|f| f[0] == '.'}
  # redraw
end

def select_current
  ## vp is local there, so i can do $vp[0]
  # open_file $view[$sta] if $view[$sta]
  open_file $view[$cursor] if $view[$cursor]
end

## create a list of dirs in which some action has happened, for saving
def push_used_dirs(d = Dir.pwd)
  # $used_dirs.index(d) || $used_dirs.push(d)
  return if $used_dirs[0] == d
  $used_dirs.delete(d) if $used_dirs.index(d)
  $used_dirs.insert(0, d)
end

def pbold text
  puts "#{BOLD}#{text}#{BOLD_OFF}"
end

# This is supposed to print on the status line
# but prints on next line.FIXME 2019-03-24 - 00:08
def perror text
  clear_last_line
  print "\r#{RED}#{text}. Press a key.#{CLEAR}"
  get_char
end

def pause text=' Press a key.'
  last_line
  print text
  get_char
end

## return shortcut/hint for an index (offset in file array)
# ix is the index of a file in the complete array (view)
def get_shortcut index

  # Case where user has panned to the right columns:
  # Earlier, we showed '<' in left columns, if user has panned right.
  # Now we show unused shortcuts after exhausting them.
  # return '<' if index < $stact
  if index < $stact
    index = $viewport.size - $stact + index
    i = $IDX[index]
    return i if i

    return '['
  end

  # Normal case (user has not panned columns)
  index -= $stact
  i = $IDX[index]
  return i if i

  '->'
end

## returns the integer offset in view (file array based on a-y za-zz and Za - Zz
# Called when user types a key
#  should we even ask for a second key if there are not enough rows
#  What if we want to also trap z with numbers for other purposes
def get_index(key, vsz = 999)
  # @log.debug "Etners get_index with #{key}"
  i = convert_key_to_index key
  return i if i

  if vsz > 25
    if key == 'z' || key == 'Z'
      last_line
      print key
      zch = get_char
      print zch
      i = convert_key_to_index("#{key}#{zch}")
      # @log.debug "convert returned #{i} for #{key}#{zch}"
      return i if i
      # i = $IDX.index
      # return i + $stact if i
    end
  end
  nil
end

# convert pressed key to an index in viewport.
# Earlier this was simple, but now that we put hints/shortcuts
#  in rows on the left after panning, we need to account for cycled hints.
def convert_key_to_index key
  i = $IDX.index(key)
  if i
    # @log.debug "get_index with #{key}: #{i}. #{$stact}. #{$viewport.size}"
    vps = $viewport.size
    # TODO: if very high key given, consider going to last file ?
    #  that way one can press zz or ZZ to go to last file.
    # 2019-04-11 - XXX actually this doesnt place the cursor on last file
    #  it opens it, which may not be what we want
    retnil = nil # vps - 1 # nil
    return retnil if $stact == 0 && i + $stact >= vps
    # return nil if $stact > 0 && i + $stact >= vps && i + $stact - vps >= $stact
    return retnil if $stact > 0 && i + $stact >= vps && i - vps >= 0

    if i + $stact >= vps
      # panning case, hints are recycled
      return (i + $stact) - vps
    else
      # regular hint
      return i + $stact #if i
    end
  end
  nil
end

def delete_file
  file_actions :delete
end

## generic external command program
#  prompt is the user friendly text of command such as list for ls, or extract for dtrx, page for less
#  pauseyn is whether to pause after command as in file or ls
#
def command_file(prompt, *command)
  pauseyn = command.shift
  command = command.join ' '
  print "[#{prompt}] Choose a file [#{$view[$cursor]}]: "
  file = ask_hint $view[$cursor]
  # print "#{prompt} :: Enter file shortcut: "
  # file = ask_hint
  perror 'Command Cancelled' unless file
  return unless file

  file = File.expand_path(file)
  if File.exist? file
    file = Shellwords.escape(file)
    pbold "#{command} #{file} (#{pauseyn})"
    system "#{command} #{file}"
    setup_terminal
    pause if pauseyn == 'y'
    refresh
  else
    perror "File #{file} not found"
  end
end

## prompt user for file shortcut and return file or nil
#
def ask_hint deflt=nil
  f = nil
  key = get_char
  return deflt if key == 'ENTER'

  ix = get_index(key, $viewport.size)
  f = $viewport[ix] if ix
  f
end

## check screen size and accordingly adjust some variables
# NOTE: tput is ncurses dependent, so use stty
#
def screen_settings
  $glines, $gcols = `stty size`.split.map{|e| e.to_i}
  # $glines = `tput lines`.to_i
  # $gcols = `tput cols`.to_i
  $grows = $glines - 3
  # $pagesize = 60
  # $gviscols = 3
  $pagesize = $grows * $gviscols
end

## Tabs to next column in multi-column displays.
#  Moves column offset so we can reach unindexed columns or entries,
#  or those with double letters
# 0 forward and any other back/prev
# direction is 0 (forward) or '1' (backward)
def column_next direction=0
  # right movement or panning cycles back to first column
  # leftward movement stops at first column.
  if direction == 0
    $stact += $grows
    $stact = 0 if $stact >= $viewport.size
    $cursor += $grows
    # 2019-03-18 - zero loses offset. we need to maintain it
    # $cursor = 0 if $cursor >= $viewport.size
    if $cursor - $sta >= $viewport.size
      $cursor -= $grows while $cursor > $sta
      $stact -= $grows while $stact > 0
      $cursor += $grows if $cursor < $sta
      $stact  += $grows if $stact < 0
    end
  else
    $stact -= $grows
    $cursor -= $grows
    $stact = 0 if $stact < 0
    # setting cursor as zero loses the position or offset
    # We are trying to maintain offset
    $cursor += $grows if $cursor < 0
  end
  # redraw
end

# currently i am only passing the action in from the list there as a key
# I should be able to pass in new actions that are external commands
# 2019-03-08 - TODO when a file name changes or moves it must be removed
#  from selection
def file_actions(action = nil)
  # only add dtrx for gz
  h = { d: :delete, D: '/bin/rm', m: :move, r: :rename, v: ENV['EDITOR'] || :vim,
        c: :copy, C: :chdir, W: :remspace, e: :execute, s: :page_stat_for_file,
        l: :less, p: :most, f: :file, o: :open, x: :dtrx, z: :zip }
  # acttext = h[action.to_sym] || action
  acttext = action || ''
  file = nil

  sct = $selected_files.size
  if sct > 0
    text = "#{sct} files"
    file = $selected_files
  else
    # 2019-03-07 - trying out direct deletes
    # why were we aksing to select a file when user is on a file
    # print "[#{acttext}] Choose a file [#{$view[$cursor]}]: "
    # file = ask_hint $view[$cursor]
    file = $view[$cursor]
    unless file
      file = ask_hint $view[$cursor]
    end
    return unless file

    text = file
  end
  # 2019-03-07 - NOTE at this point file can be one or more files.
  # 2019-03-07 - text can be a file or count of files, so unreliable !!! FIXME

  case file
  when Array
    # escape the contents and create a string
    files = Shellwords.join(file)
  when String
    files = Shellwords.escape(file)
  end

  key = nil
  if action
    menu_text = action
  else
    key, menu_text = menu "File Menu for #{text}", h
    menu_text = :quit if key == 'q'
  end
  return unless menu_text # pressed some wrong key

  case menu_text.to_sym

  when :quit

  when :delete
    delcommand = 'rmtrash'
    last_line
    print "#{delcommand} #{text} ? [yn?]: "
    key = get_char
    view_selected_files if key == '?'
    return if key != 'y'

    clear_last_line
    print "\r deleting ..."
    system "#{delcommand} #{files}"
    refresh

  when :move
    # 2019-03-07 - NOTE this will only work with single file selection
    # target = gets().chomp
    # target = Readline.readline('>', true)
    target = readline "Move #{text} to : "
    return unless target

    target = '.' if target == ''
    # 2019-03-07 - NOTE cannot use text if multiple files
    # text = File.expand_path(text)
    target = File.expand_path(target)
    return if target == ''

    if File.directory? target
      begin
        FileUtils.mv file, target
        message "Moved #{text} to #{target}"
      rescue StandardError => exc
        perror exc.to_s
      end
      # 2019-03-08 - TODO if success remove from selection
      refresh
    else
      perror 'Target not a dir'
    end

  when :copy
    # Target must be directory
    target = readline "Copy #{text} to : "
    return unless target # C-c

    target = '.' if target == ''
    target = File.expand_path(target)
    return if target == ''

    if File.directory? target
      begin
        FileUtils.cp file, target
        message "Copied #{text} to #{target}"
      rescue StandardError => exc
        perror exc.to_s
      end
      refresh
    else
      perror 'Copy target must be a dir'
    end

  when :chdir
    change_dir File.dirname(text)

  when :zip
    # target = gets().chomp
    target = readline 'Archive name: '
    return unless target
    return if target == ''

    # don't want a blank space or something screwing up
    if target && target.size > 3
      if File.exist? target
        perror "Target (#{target}) exists"
      else
        system "tar zcvf #{target} #{files}"
        setup_terminal
        refresh
      end
    end

  when :rename
    # 2019-03-07 NOTE works for single file FIXME
    # 2019-03-07 - TODO for n files replace pattern with string
    target = readline "Rename #{text} to : "
    return if target == ''

    text = File.expand_path(text)
    target = File.basename(text) if target == '.'
    if File.exist? target
      perror "Target (#{target}) exists"
    else
      FileUtils.mv text, target
      refresh
    end
  when :most, :less, :vim
    system "#{menu_text} #{files}"
    setup_terminal
    # should we remove from selection ?

  when :remspace
    # 2019-03-08 - 00:07 added replace space with underscore in filename
    print "Remove spaces from #{file}"
    pause
    farray = nil

    # stupidly using one variable for scalar and array DUH !
    case file
    when String
      farray = [file]
    when Array
      farray = file
    end

    farray.each do |f|
      if f.index ' '
        nname = f.tr(' ', '_')
        FileUtils.mv f, nname unless File.exist? nname
        # if success then remove from selection
      end
    end
    refresh
  when :execute
    execute
  when :page_stat_for_file
    1
    # already been executed by menu
    # We could have just put 'stat' in the menu but that doesn't look so nice
  else
    return unless menu_text

    last_line
    pause "#{menu_text} #{files} "
    system "#{menu_text} #{files}"
    setup_terminal
    refresh
  end

  # remove non-existent files from select list due to move or delete
  #  or rename or whatever
  if sct > 0
    $selected_files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  end
end

# increase or decrease column
def columns_incdec(howmany)
  $gviscols += howmany.to_i
  $gviscols = 1 if $gviscols < 1
  $gviscols = 6 if $gviscols > 6
  $pagesize = $grows * $gviscols
end

# bind a key to an external command wich can be then be used for files
def bindkey_ext_command
  print
  pbold 'Bind a capital letter to an external command'
  print 'Enter a capital letter to bind: '
  key = get_char
  return if key == 'Q'

  if key =~ /^[A-Z]$/
    print "Enter an external command to bind to #{key}: "
    com = gets.chomp
    if com != ''
      print 'Enter prompt for command (blank if same as command): '
      pro = gets.chomp
      pro = com if pro == ''
    end
    print 'Pause after output [y/n]: '
    yn = get_char
    $bindings[key] = "command_file #{pro} #{yn} #{com}"
  end
end

# execute a command on selected or current file
def execute
  if $selected_files.empty?
    run_command current_file
    return
  end
  run_command $selected_files
end

def ag
  pattern = readline 'Enter a pattern to search (ag): '
  return if pattern == ''

  $title = "Files found using 'ag -t: ' #{pattern}"

  ## ag options :
  #     -t : all text files
  #     -l : print only file names
  #     -a : print all files, even ignored
  system %[ag -t "#{pattern}"]

  pause
  files = `ag -lt "#{pattern}"`.split("\n")
  if files.empty?
    perror "No files found for #{pattern}."
    $title = nil
    return
  end
  $files = files
  # redraw
end

def ffind
  last_line
  # print 'Enter a file name pattern to find: '
  pattern = readline '! find . -iname :'
  return if pattern == ''

  $title = "Files found using 'find' #{pattern}"
  files = `find . -iname "#{pattern}"`.split("\n")
  if files.empty?
    perror 'No files found. Try adding *'
  else
    $files = files
  end
  # redraw
end

def locate
  print 'Enter a file name pattern to locate: '
  pattern = readline
  return if pattern == ''

  $title = "Files found using 'locate' #{pattern}"
  files = `locate #{pattern}`.split("\n")
  files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  if files.empty?
    perror 'No files found.'
  else
    $files = files
  end
  # redraw
end

##  takes directories from the z program, if you use autojump you can
#   modify this accordingly
#
def z_interface
  file = File.expand_path('~/.z')
  return unless File.exist? file

  $title = 'Directories from ~/.z'
  $files = `sort -rn -k2 -t '|' ~/.z | cut -f1 -d '|'`.split("\n")
  home = ENV['HOME']
  # shorten file names
  $files.collect! do |f|
    f.sub(/#{home}/, '~')
  end
  # redraw
end

def vidir
  system 'vidir'
  setup_terminal
end

# ------------- movement related methods --------------------------------#

## scroll cursor down
def cursor_scroll_dn
  $movement = :down
  moveto(pos + MSCROLL)
end

def cursor_scroll_up
  $movement = :up
  moveto(pos - MSCROLL)
end

# move cursor down a line
def cursor_dn
  $movement = :down
  $old_cursor = $cursor
  moveto(pos + 1)
end

def cursor_up
  $old_cursor = $cursor
  $movement = :up
  moveto(pos - 1)
end

# return cursor position
def pos
  $cursor
end

# move cursor to given position/line
def moveto position
  orig = $cursor
  $cursor = position
  $cursor = [$cursor, $view.size - 1].min
  $cursor = [$cursor, 0].max

  # try to stop it from landing on separator
  if current_file == SEPARATOR
    $cursor += 1 if $movement == :down
    $cursor -= 1 if $movement == :up
    return
  end

  # 2019-03-18 - adding sta
  # $sta = position - only when page flips and file not visible
  # FIXME not correct, it must stop at end or correctly cycle
  # sta goes to 0 but cursor remains at 70
  # viewport.size may be wrong here, maybe should be pagesize only
  oldsta = $sta
  if $cursor - $sta >= $pagesize
    $sta += $pagesize
  # elsif $sta - $cursor >= $viewport.size
  end
  if $sta > $cursor
    $sta -= $pagesize
    # $sta = $cursor
  end

  $movement = nil if oldsta != $sta # we need to redraw

  star = [orig, $cursor].min
  fin = [orig, $cursor].max
  return unless $visual_mode

  $movement = nil # visual mode needs to redraw page

  # PWD has to be there in selction
  if selected? current_file
    # this depends on the direction
    # $selected_files = $selected_files - $view[star..fin]
    remove_from_selection $view[star..fin]
    ## current row remains in selection always.
    add_to_selection current_file
  else
    # $selected_files.concat $view[star..fin]
    add_to_selection $view[star..fin]
  end
  message "#{$selected_files.count} files selected.   "
# ensure
  # redraw
end
# --

# is given file in selected array
def visited?(file)
  $current_dir ||= Dir.pwd
  file = File.join($current_dir, file)
  return $visited_files.index file
end

# ------------- selection related methods --------------------------------#

# is given file in selected array
def selected?(file)
  $current_dir ||= Dir.pwd
  file = File.join($current_dir, file)
  return $selected_files.index file
end

# add given file/s to selected file list
def add_to_selection(file)
  ff = file
  case file
  when String
    ff = [file]
  end
  $current_dir ||= Dir.pwd
  ff.each do |f|
    full = File.join($current_dir, f)
    $selected_files.push(full) unless $selected_files.include?(full)
  end
end

def remove_from_selection(file)
  ff = file
  case file
  when String
    ff = [file]
  end
  $current_dir ||= Dir.pwd
  ff.each do |f|
    full = File.join($current_dir, f)
    $selected_files.delete full
  end
end

# ------------- visual mode methods --------------------------------#
def visual_mode_toggle
  $mode = nil
  $visual_mode = !$visual_mode
  if $visual_mode
    $mode = 'VIS'
    $visual_block_start = $cursor
    add_to_selection current_file
  end
  message "Visual mode is #{$visual_mode}."
end

# Called from Escape key only. Clears selection.
def visual_block_clear
  if $visual_block_start
    star = [$visual_block_start, $cursor].min
    fin = [$visual_block_start, $cursor].max
    remove_from_selection $view[star..fin]
  end
  $visual_block_start = nil
  $visual_mode = nil
  $mode = nil if $mode == 'VIS'
end

# ------------- file matching methods --------------------------------#
def file_starting_with first_char=nil
  unless first_char
    clear_last_line
    print "\rEnter first char: "
    first_char = get_char
  end
  ix = return_next_match(method(:file_matching?), "^#{first_char}")
  goto_line ix if ix
end

def file_matching?(file, patt)
  file =~ /#{patt}/
end

## generic method to take cursor to next position for a given condition
def return_next_match(binding, *args)
  first = nil
  ix = 0
  $view.each_with_index do |elem, ii|
    next unless binding.call(elem, *args)

    first ||= ii
    if ii > $cursor
      ix = ii
      break
    end
  end
  return first if ix == 0

  ix
end

##
# position cursor on a specific line which could be on a nother page
# therefore calculate the correct start offset of the display also.
def goto_line pos
  pages = ((pos * 1.00) / $pagesize).ceil
  pages -= 1
  $sta = pages * $pagesize + 1
  $cursor = pos
end

# return filetype of file using `file` external command.
# NOTE: Should we send back executable as separate type or allow
#  it to be nil, so it will be paged.
def filetype f
  return nil unless f

  f = Shellwords.escape(f)
  s = `file #{f}`
  return :text if s.index 'text'
  return :zip if s.index(/[Zz]ip/)
  return :zip if s.index('archive')
  return :image if s.index 'image'
  return :text if s.index 'data'

  nil
end

# save offset in directory so we can revert to it when we return
def save_dir_pos
  # the next line meant that it would not save first directory.
  # return if $sta == 0 && $cursor == 0

  $dir_position[Dir.pwd] = [$sta, $cursor]
end

# revert to the position we were at in this directory
def revert_dir_pos
  $sta = 0
  $cursor = 0
  a = $dir_position[Dir.pwd]
  if a
    $sta = a.first
    $cursor = a[1]
    raise "sta is nil for #{Dir.pwd} : #{$dir_position[Dir.pwd]}" unless $sta
    raise 'cursor is nil' unless $cursor
  end
end

def create_a_dir
  str = readline 'Enter directory name: '
  return if str == ''

  if File.exist? str
    perror "#{str} exists."
    return
  end
  begin
    FileUtils.mkdir str
    $used_dirs.insert(0, str) if File.exist?(str)
    refresh
  rescue StandardError => ex
    perror "Error in newdir: #{ex}"
  end
end

def create_a_file
  str = readline 'Enter file name: '
  return if str.nil? || str == ''

  system %($EDITOR "#{str}")
  setup_terminal
  $visited_files.insert(0, str) if File.exist?(str)
  refresh
end

# convenience method to return file under cursor
def current_file
  $view[$cursor]
end

def current_or_selected_files
  return $selected_files if !$selected_files.empty?

  return [current_file]
end

# ------------------- scripts ------------------ #
# prompt for scripts to execute, giving file name under cursor
def scripts
  # some scripts may work with the selected_files and not want to be called
  #  with filenames.
  write_selected_files

  title = 'Select a script'
  script_path = '~/.config/cetus/scripts'
  binding = `find #{script_path} -type f | fzf --prompt="#{title} :"`.chomp
  return if binding.nil? || binding == ''

  # TODO: check if binding is a file and executable
  # xargs only seems to take the first file
  # cf = current_or_selected_files.join('\0')
  # cf = Shellwords.join(current_or_selected_files)
  # This was getting called repeatedly even if script used selected_files
  # current_or_selected_files.each do |file|
    # system %( #{binding} "#{file}" )
  # end

  # 2019-04-08 - to avoid confusion, we pass name of file under cursor
  # script may ignore this and use selected_files
  system %( #{binding} "#{current_file}" )

  # system %(echo "#{cf}" | xargs #{binding})
  pause
  redraw_required
end

# allow user to select a script that generates filenames which
#  will be displayed for selection or action.
def generators
  write_selected_files

  title = 'Select a generator'
  script_path = '~/.config/cetus/generators'
  binding = `find #{script_path} -type f | fzf --prompt="#{title} :"`.chomp
  return if binding.nil? || binding == ''

  # call generator and accept list of files
  $title = "Files from #{File.basename(binding)}"
  $files = `#{binding} "#{current_file}"`.split("\n")

end
# ------------- end of scripts --------------------------------#

# ------------------- view_selected_files ------------------ #
def view_selected_files
  fname = write_selected_files

  unless fname
    message "No file selected.    "
    return
  end

  system "$PAGER #{fname}"
  setup_terminal
end
# ------------- end of view_selected_files --------------------------------#

# write selected files to a file and return path
# if no selected files then blank out the file, or else
# script could use old selection again.
def write_selected_files

  # fname = File.join(File.dirname(CONFIG_FILE), 'selected_files')
  # 2019-04-10 - changed to ~/tmp otherwise confusion about location
  fname = File.join('~/tmp/', 'selected_files')
  fname = File.expand_path(fname)

  # remove file if no selection
  unless $selected_files
    File.unlink(fname)
    return nil
  end

  File.open(fname, 'w') do |file|
    $selected_files.each { |row| file.puts row }
  end

  return fname
end
##
# Editing of the User Dir List.
# remove current entry from used dirs list, since we may not want some entries being there
#
def remove_from_list
  unless $selected_files.empty?
    sz = $selected_files.size
    print "Remove #{sz} files from used list (y)?: "
    key = get_char
    return if key != 'y'

    arr = $selected_files.map { |path| File.expand_path(path) }

    $used_dirs = $used_dirs - arr
    $visited_files = $visited_files - arr
    unselect_all
    $modified = true
    refresh
    return
  end

  # no file selected, use file under cursor
  print
  ## what if selected some rows
  file = $view[$cursor]
  print "Remove #{file} from used list (y)?: "
  key = get_char
  return if key != 'y'

  file = File.expand_path(file)
  if File.directory? file
    $used_dirs.delete(file)
  else
    $visited_files.delete(file)
  end
  refresh
  $modified = true
end

#
# If there's a short file list, take recently mod and accessed folders and put latest
# files from there and insert it here. I take both since recent mod can be binaries / object
# files and gems created by a process, and not actually edited files. Recent accessed gives
# latest source, but in some cases even this can be misleading since running a program accesses
# include files.
def enhance_file_list
  return unless $enhanced_mode
  begin
    actr = $files.size

  # zshglob: M = MARK_DIRS with slash
  # zshglob: N = NULL_GLOB no error if no result, this is causing space to split
  #  file sometimes for single file.

  # FIXME: append only if we are adding.
  # FIXME: this makes it possible to select this row,
  # FIXME: and count it as a file !!
  # $files.append SEPARATOR

  # if only one entry and its a dir
  # get its children and maybe the recent mod files a few
  # FIXME: simplify condition into one
  if $files.size == 1
    # its a dir, let give the next level at least
    return unless $files.first[-1] == '/'

    d = $files.first
    # zshglob: 'om' = ordered on modification time
    # f1 = `zsh -c 'print -rl -- #{d}*(omM)'`.split("\n")
    f = get_files_by_mtime(d)

    # @log.warn "f1:#{f1} != f:#{f} in #{d}" if f1 != f
    # order returned by zsh and ruby are different since the time is the same

    # TODO: use ruby this throws errors if not files
    if f && !f.empty?
      # @log.debug "CONCAT: #{f}" if @debug_flag
      $files.concat f
      $files.concat get_important_files(d)
    end
    return
  end
  #
  # check if a ruby project dir, although it could be a backup file too,
  # if so , expand lib and maybe bin, put a couple recent files
  # FIXME: gemspec file will be same as current folder
  if $files.index('Gemfile') || !$files.grep(/\.gemspec/).empty?
    # usually the lib dir has only one file and one dir
    flg = false
    $files.concat get_important_files(Dir.pwd)
    if $files.index('lib/')
      # get first five entries by modification time
      # f1 = `zsh -c 'print -rl -- lib/*(om[1,5]MN)'`.split("\n")
      f = get_files_by_mtime('lib')&.first(5)
      # @log.warn "f1 #{f1} != #{f} in lib" if f1 != f
      if f && !f.empty?
        insert_into_list('lib/', f)
        flg = true
      end

      # look into lib file for that project
      dd = File.basename(Dir.pwd)
      if f.index("lib/#{dd}/")
        # f1 = `zsh -c 'print -rl -- lib/#{dd}/*(om[1,5]MN)'`.split("\n")
        f = get_files_by_mtime("lib/#{dd}")&.first(5)
        # @log.warn "2756 f1 #{f1} != #{f} in lib/#{dd}" if f1 != f
        if f && !f.empty?
          insert_into_list("lib/#{dd}/", f)
          flg = true
        end
      end
    end

    # look into bin directory and get first five modified files
    if $files.index('bin/')
      # f1 = `zsh -c 'print -rl -- bin/*(om[1,5]MN)'`.split("\n")
      f = get_files_by_mtime("bin")&.first(5)
      # @log.warn "2768 f1 #{f1} != #{f} in bin/" if f1 != f
      insert_into_list('bin/', f) if f && !f.empty?
      flg = true
    end
    return if flg

    # lib has a dir in it with the gem name

  end
  return if $files.size > 15

  # Get most recently accessed directory
  ## NOTE: first check accessed else modified will change accessed
  # 2019-03-28 - adding NULL_GLOB breaks file name on spaces
  # print -n : don't add newline
  # zzmoda = `zsh -c 'print -rn -- *(/oa[1]MN)'`
  # zzmoda = nil if zzmoda == ''
  moda = get_most_recently_accessed_dir
  # @log.warn "Error 2663 #{zzmoda} != #{moda}" if zzmoda != moda
  if moda && moda != ''

    # get most recently accessed file in that directory
    # NOTE: adding NULL_GLOB splits files on spaces
    # FIXME: this zsh one gave a dir instead of file.
    # zzmodf = `zsh -c 'print -rl -- #{moda}*(oa[1]M)'`.chomp
    # zzmodf = nil if zzmodf == ''
    modf = get_most_recently_accessed_file moda
    # @log.warn "Error 2670 (#{zzmodf}) != (#{modf}) gmra in #{moda} #{zzmodf.class}, #{modf.class} : Loc: #{Dir.pwd}" if zzmodf != modf

    raise "2784: #{modf}" if modf && !File.exist?(modf)

    insert_into_list moda, modf if modf && modf != ''

    # get most recently modified file in that directory
    # zzmodm = `zsh -c 'print -rn -- #{moda}*(om[1]M)'`.chomp
    modm = get_most_recently_modified_file moda
    # zzmodm = nil if zzmodm == ''
    # @log.debug "Error 2678 (gmrmf) #{zzmodm} != #{modm} in #{moda}" if zzmodm != modm
    raise "2792: #{modm}" if modm && !File.exist?(modm)

    insert_into_list moda, modm if modm && modm != '' && modm != modf
  end

  ## get most recently modified dir
  # zzmodm = `zsh -c 'print -rn -- *(/om[1]M)'`
  # zzmodm = nil if zzmodm == ''
  modm = get_most_recently_modified_dir
  # @log.debug "Error 2686 rmd #{zzmodm} != #{modm}" if zzmodm != modm

  if modm != moda

    # get most recently accessed file in that directory
    # modmf = `zsh -c 'print -rn -- #{modm}*(oa[1]M)'`
    modmf = get_most_recently_accessed_file modm
    raise "2806: #{modmf}" if modmf && !File.exist?(modmf)

    insert_into_list modm, modmf

    # get most recently modified file in that directory
    # modmf11 = `zsh -c 'print -rn -- #{modm}*(om[1]M)'`
    modmf1 = get_most_recently_modified_file modm
    raise "2812: #{modmf1}" if modmf1 && !File.exist?(modmf1)

    insert_into_list(modm, modmf1) if modmf1 != modmf
  else
    # if both are same then our options get reduced so we need to get something more
    # If you access the latest mod dir, then come back you get only one, since mod and accessed
    # are the same dir, so we need to find the second modified dir
  end
  ensure
    # if any files were added, then add a separator
    bctr = $files.size
    if actr < bctr
      $files.insert actr, SEPARATOR
    end
  end
end

# insert important files to end of $files
def insert_into_list _dir, file
  $files.push(*file)
end

# Get visited files and bookmarks that are inside this directory
#  at a lower level.
# 2019-03-23 - not exactly clear what is happening XXX
# this gets a directory (containing '/' at end)
def get_important_files dir

  # checks various lists like visited_files and bookmarks
  # to see if files from this dir or below are in it.
  # More to be used in a dir with few files.
  list = []
  l = dir.size + 1

  # 2019-03-23 - i think we are getting the basename of the file
  #  if it is present in the given directory XXX
  $visited_files.each do |e|
    list << e[l..-1] if e.index(dir) == 0
  end

  # bookmarks if it starts with this directory then add it
  # FIXME it puts same directory cetus into the list with full path
  # We need to remove the base until this dir. get relative part
  list1 = $bookmarks.values.select do |e|
    e.index(dir) == 0 && e != dir
  end

  list.concat list1
  list
end

def get_most_recently_accessed_dir dir='.'
  gmr dir, :directory?, :atime
end

def get_most_recently_accessed_file dir='.'
  gmr dir, :file?, :atime
end

def get_most_recently_modified_file dir='.'
  gmr dir, :file?, :mtime
end

def get_most_recently_modified_dir dir='.'
  file = gmr dir, :directory?, :mtime
end

# get most recent file or directory, based on atime or mtime
# dir is name of directory in which to get files, default is '.'
# type is :file? or :directory?
# func can be :mtime or :atime or :ctime or :birthtime
def gmr dir, type, func
  file = Dir.glob(dir + '/*')
            .select { |f| File.send(type, f) }
            .max_by { |f| File.send(func, f) }
  file = File.basename(file) + '/' if file && type == :directory?
  return file.gsub('//', '/') if file

  nil
end

# return a list of entries sorted by mtime.
# A / is added after to directories
def get_files_by_mtime dir='*'
  gfb dir, :mtime
end

def get_files_by_atime dir='.'
  gfb dir, :atime
end

# get files ordered by mtime or atime, returning latest first
# dir is dir to get files in, default '.'
# func can be :atime or :mtime or even :size or :ftype
def gfb dir, func
  dir += '/*' if File.directory?(dir)
  dir = dir.gsub('//', '/')

  # sort by time and then reverse so latest first.
  sorted_files = Dir[dir].sort_by { |f| File.send(func, f) }.reverse

  # add slash to directories
  sorted_files = add_slash sorted_files
  return sorted_files
end

# set message which will be displayed in status line
# TODO: maybe we should pad it 2019-04-08 -
def message mess
  $message = mess
end

def last_line
  # system "tput cup #{$glines} 0"
  # print "\e[#{$glines};0H"
  tput_cup $glines, 0
end

def clear_last_line
  last_line
  # print a colored line at bottom of screen
  # \e[33;41m  - set color of status_line
  # %*s        - set blank spaces for entire line
  # \e[m       - reset text mode
  # \r         - bring to start of line since callers will print.
  print "\e[33;4%sm%*s\e[m\r" % [$status_color || '1', $gcols, " "]
end

# print right aligned
# XXX does not clear are, if earlier text was longer then that remains.
# TODO: 2019-04-10 - this should update a variable, and status_line
# should clear and reprint mode, message, patt and right text
def print_on_right text
  sz = text.size
  col = $gcols - sz - 1
  col = 2 if col < 2
  if sz > $gcols - 2
    text = text[0..$gcols-3]
  end
  # system "tput cup #{$glines} #{$gcols - sz - 1}"
  system "tput cup #{$glines} #{col}"
  # tput_cup $glines, $gcols - sz - 1
  # print text
  print "\e[33;4#{$status_color}m#{text}\e[m"
end

# unused, should set bgcolor before printing
def print_last_line text
  # unused ??
  last_line
  print text
end

# main loop which calls all other programs
def run

  Signal.trap('EXIT') do
    reset_terminal
    exit
  end

  setup_terminal
  config_read
  parse_ls_colors
  set_bookmark '0'

  redraw true
  place_cursor

  # do we need this, have they changed after redraw
  $patt = nil
  $sta = 0

  # forever loop that prints dir and takes a key
  loop do

    key = get_char

    unless resolve_key key # key did not map to file name, so don't redraw
      place_cursor
      next
    end

    # only movement has happened within this page, don't redraw
    if $movement && $old_cursor

      # we may want to print debug info if flag is on
      if @debug_flag
        clear_last_line
        print_debug_info
      elsif @filename_status_line
        print_filename_status_line
      end

      place_cursor
      $movement = false
      next
    end

    redraw rescan?
    place_cursor

    break if $quitting
  end
  write_curdir
  puts 'bye'
  config_write if $writing
  @log&.close
end

run
