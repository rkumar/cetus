#!/usr/bin/env ruby
# --------------------------------------------------------------------------- #
#         File: cetus
#  Description: Fast file navigation, a tiny version of zfm
#               but with a different indexing mechanism
#       Author: rkumar http://github.com/rkumar/cetus/
#         Date: 2013-02-17 - 17:48
#      License: GPL
#  Last update: 2019-03-20 11:43
# --------------------------------------------------------------------------- #
#  cetus.rb  Copyright (C) 2012-2019 rahul kumar
# == CHANGELOG
# 2019-02-20 - added smcup and rmcup so alt-screen is used. works a bit
# 2019-03-04 - change clear to go to 0,0 and clear down to reduce pollution
# 2019-03-04 - changed quit to q (earlier Q)
# 2019-03-04 - first dirs then files
# 2019-03-10 - changing selected_files to have fullpath
#  == TODO
#  To dirs add GEMHOME RUBYLIB PYTHONILB or PYTHONPATH,
#  Make rubygem aware : gemspec or Gemfile the expand lib and bin
#  fpath if existing

require 'readline'
require 'io/wait'
# http://www.ruby-doc.org/stdlib-1.9.3/libdoc/shellwords/rdoc/Shellwords.html
require 'shellwords'
# https://docs.ruby-lang.org/en/2.6.0/FileUtils.html
require 'fileutils'
# -- requires 1.9.3 for io/wait

## INSTALLATION
# copy into PATH
# alias c=~/bin/cetus.rb
# c

# 2019-02-20 - added so alt-screen is used
system 'tput smcup'
VERSION = '0.1.26.0'.freeze
CONFIG_FILE = '~/.config/cetus/conf.yml'.freeze

$bindings = {}
$bindings = {
  '`' => 'main_menu',
  '=' => 'toggle_menu',
  'M-y' => 'selection_menu',
  'M-s' => 'sort_menu',
  'ENTER' => 'select_current',
  'C-p' => 'page_current',
  'C-e' => 'edit_current',
  'C-o' => 'edit_current',
  'C-s' => 'toggle_select',
  'C-r' => 'reduce',
  'C-g' => 'debug_vars',
  '@' => 'selection_mode_toggle',
  'M-a' => 'select_all',
  'M-A' => 'unselect_all',
  '!' => 'execute',
  ',' => 'goto_parent_dir',
  '~' => 'goto_home_dir',
  '-' => 'goto_previous_dir', # 2019-03-07 - added. like 'cd ='
  '+' => 'goto_dir',       # 2019-03-07 - TODO: change binding
  '.' => 'pop_dir',
  ':' => 'subcommand',
  "'" => 'goto_bookmark',
  '/' => 'enter_regex',
  'M-p' => 'prev_page',
  'M-n' => 'next_page',
  'SPACE' => 'next_page',
  'M-f' => 'select_visited_files',
  'M-d' => 'select_used_dirs',
  'M-b' => 'bookmark_menu',
  'M-m' => 'create_bookmark',
  'M-M' => 'view_bookmarks',
  'C-c' => 'escape',
  'ESCAPE' => 'escape',
  'TAB' => 'views',
  'C-i' => 'views',
  # '?' => 'dirtree',
  'D' => 'delete_file',
  'M' => 'file_actions most',
  'q' => 'quit_command', # was Q now q 2019-03-04 -
  # "RIGHT"   => "column_next",
  'RIGHT' => 'select_current', # changed 2018-03-12 - for faster navigation
  'LEFT' => 'goto_parent_dir', # changed on 2018-03-12 - earlier column_next 1
  ']' => 'column_next',
  '[' => 'column_next 1',
  'C-x' => 'file_actions',
  'M--' => 'columns_incdec -1',
  'M-+' => 'columns_incdec 1',
  'S' => 'command_file list y ls -lh',
  'L' => 'command_file Page n less',
  'C-d' => 'cursor_scroll_dn',
  'C-b' => 'cursor_scroll_up',
  'UP' => 'cursor_up',
  'DOWN' => 'cursor_dn',
  'C-SPACE' => 'visual_mode_toggle',

  '?' => 'print_help',
  'F1' => 'print_help',
  'F2' => 'child_dirs',
  'F3' => 'dirtree',
  'F4' => 'tree',
  'S-F1' => 'dirtree',
  'S-F2' => 'tree'

}

## clean this up a bit, copied from shell program and macro'd
$kh = {}
$kh["\eOP"] = 'F1'
$kh["\e[A"] = 'UP'
$kh["\e[5~"] = 'PGUP'
$kh[''] = 'ESCAPE'
KEY_PGDN = "\e[6~".freeze
KEY_PGUP = "\e[5~".freeze
## I needed to replace the O with a [ for this to work
#  in Vim Home comes as ^[OH whereas on the command line it is correct as ^[[H
KEY_HOME = '[H'.freeze
KEY_END = "\e[F".freeze
KEY_F1 = "\eOP".freeze
KEY_UP = "\e[A".freeze
KEY_DOWN = "\e[B".freeze

$kh[KEY_PGDN] = 'PgDn'
$kh[KEY_PGUP] = 'PgUp'
$kh[KEY_HOME] = 'Home'
$kh[KEY_END] = 'End'
$kh[KEY_F1] = 'F1'
$kh[KEY_UP] = 'UP'
$kh[KEY_DOWN] = 'DOWN'
KEY_LEFT = '[D'.freeze
KEY_RIGHT = '[C'.freeze
$kh["\eOQ"] = 'F2'
$kh["\eOR"] = 'F3'
$kh["\eOS"] = 'F4'
$kh[KEY_LEFT] = 'LEFT'
$kh[KEY_RIGHT] = 'RIGHT'
KEY_F5 = '[15~'.freeze
KEY_F6 = '[17~'.freeze
KEY_F7 = '[18~'.freeze
KEY_F8 = '[19~'.freeze
KEY_F9 = '[20~'.freeze
KEY_F10 = '[21~'.freeze
KEY_S_F1 = '[1;2P'.freeze
$kh[KEY_F5] = 'F5'
$kh[KEY_F6] = 'F6'
$kh[KEY_F7] = 'F7'
$kh[KEY_F8] = 'F8'
$kh[KEY_F9] = 'F9'
$kh[KEY_F10] = 'F10'
# testing out shift+Function. these are the codes my kb generates
$kh[KEY_S_F1] = 'S-F1'
$kh['[1;2Q'] = 'S-F2'

def old_clear_screen
  system 'clear'
  return
  system('tput cup 0 0')
  # system 'tput ed'
  print "\e[J"
end

# copied from fff
def clear_screen
  # Only clear the scrolling window (dir item list).
  # '\e[%sH':    Move cursor to bottom of scroll area.
  # '\e[9999C':  Move cursor to right edge of the terminal.
  # '\e[1J':     Clear screen to top left corner (from cursor up).
  # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
  # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
  #              Also sets cursor to (0,0).
  # ENV["TMUX:+\e[2J]"],
  printf("\e[%sH\e[9999C\e[1J\e[1;%sr", \
         $glines - 0, # was 2
         $glines) # was grows
end

# copied from fff
# Call before shelling to editor pager and when exiting
def reset_terminal
  # Reset the terminal to a useable state (undo all changes).
  # '\e[?7h':  Re-enable line wrapping.
  # '\e[?25h': Unhide the cursor.
  # '\e[2J':   Clear the terminal.
  # '\e[;r':   Set the scroll region to its default value.
  #            Also sets cursor to (0,0).
  print "\e[?7h\e[?25h\e[2J\e[;r"

  # Show user input.
  system 'stty echo'
end

# copied from fff
# call AFTER shelling to most or vim
def setup_terminal
  # Setup the terminal for the TUI.
  # '\e[?7l':    Disable line wrapping.
  # '\e[?25l':   Hide the cursor.
  # '\e[2J':     Clear the screen.
  # '\e[1;Nr':   Limit scrolling to scrolling area.
  #              Also sets cursor to (0,0).
  printf("\e[?7l\e[?25l\e[2J\e[1;%sr", $glines)
  # earlier glines was grows

  # Hide echoing of user input
  system 'stty -echo'
end

# wrap readline so C-c can be ignored, but blank is taken as default
def readline
  begin
    target = Readline.readline('>', true)
  rescue Interrupt
    return nil
  end
  target
end

## get a character from user and return as a string
# Adapted from:
# http://stackoverflow.com/questions/174933/how-to-get-a-single-character-without-pressing-enter/8274275#8274275
# Need to take complex keys and matc against a hash.
def get_char
  system('stty raw -echo 2>/dev/null') # turn raw input on
  c = nil
  # if $stdin.ready?
  c = $stdin.getc
  cn = c.ord
  return 'ENTER' if cn == 10 || cn == 13
  return 'BACKSPACE' if cn == 127
  return 'C-SPACE' if cn == 0
  return 'SPACE' if cn == 32
  # next does not seem to work, you need to bind C-i
  return 'TAB' if cn == 8

  if cn >= 0 && cn < 27
    x = cn + 96
    return "C-#{x.chr}"
  end
  if c == ''
    buff = c.chr
    loop do
      k = nil
      if $stdin.ready?
        k = $stdin.getc
        # puts "got #{k}"
        buff += k.chr
      else
        x = $kh[buff]
        return x if x

        # puts "returning with  #{buff}"
        if buff.size == 2
          ## possibly a meta/alt char
          k = buff[-1]
          return "M-#{k.chr}"
        end
        return buff
      end
    end
  end
  # end
  return c.chr if c
ensure
  # system "stty -raw echo" # turn raw input off
  system('stty -raw echo 2>/dev/null') # turn raw input on
end

## GLOBALS
# $IDX="123456789abcdefghijklmnoprstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
# $IDX="abcdefghijklmnopqrstuvwxy"
$IDX = ('a'..'y').to_a
$IDX.delete 'q'
$IDX.concat ('za'..'zz').to_a
$IDX.concat ('Za'..'Zz').to_a
$IDX.concat ('ZA'..'ZZ').to_a

$selected_files = []
$bookmarks = {}
$mode = nil
$glines = `tput lines`.to_i
$gcols = `tput cols`.to_i
$grows = $glines - 3  # can be a func
# $pagesize = 60
$gviscols = 3
$pagesize = $grows * $gviscols # can be a func
$stact = 0
# $editor_mode = true
$editor_mode = false # changed 2018-03-12 - so we start in pager mode
$enhanced_mode = true
$visual_block_start = nil
$pager_command = {
  text: 'most',
  image: 'open',
  zip: 'tar ztvf %% | most',
  unknown: 'open'
}
$dir_position = {}
## CONSTANTS
GMARK = '*'.freeze
CURMARK = '>'.freeze
MSCROLL = 10
SPACE = ' '.freeze
CLEAR      = "\e[0m".freeze
BOLD       = "\e[1m".freeze
BOLD_OFF = "\e[22m".freeze
RED = "\e[31m".freeze
ON_RED = "\e[41m".freeze
GREEN      = "\e[32m".freeze
YELLOW     = "\e[33m".freeze
BLUE       = "\e[1;34m".freeze

ON_BLUE    = "\e[44m".freeze
REVERSE    = "\e[7m".freeze
UNDERLINE    = "\e[4m".freeze
CURSOR_COLOR = ON_BLUE
$patt = nil
$ignorecase = true
$quitting = false
$modified = $writing = false
$visited_files = []
## dir stack for popping
$visited_dirs = []
## dirs where some work has been done, for saving and restoring
$used_dirs = []
$default_sort_order = 'om'
$sorto = $default_sort_order
$viewctr = 0
$history = []
## sta is where view (viewport) begins, cursor is current row/file
$sta = $cursor = 0
$visual_mode = false
$status_color = 4 # status line, can be 2 3 4 5 6
# $help = "#{BOLD}1-9a-zA-Z#{BOLD_OFF} Select #{BOLD}/#{BOLD_OFF} Grep #{BOLD}'#{BOLD_OFF} First char  #{BOLD}M-n/p#{BOLD_OFF} Paging  #{BOLD}!#{BOLD_OFF} Execute #{BOLD}@#{BOLD_OFF} Selection Mode  #{BOLD}q#{BOLD_OFF} Quit"

# Menubar on top of screen
$help = "#{BOLD}?#{BOLD_OFF} Help   #{BOLD}`#{BOLD_OFF} Menu   #{BOLD}!#{BOLD_OFF} Execute   #{BOLD}=#{BOLD_OFF} Toggle   #{BOLD}C-x#{BOLD_OFF} File Actions  #{BOLD}q#{BOLD_OFF} Quit "

## main loop which calls all other programs
def run
  home = ENV['HOME']
  ctr = 0
  config_read
  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}M)'`.split("\n")
  $files = sort_file_list $files
  enhance_file_list
  ## added by RK 2014-03-31 - 00:29 since too many duplicates
  $files = $files.uniq if $enhanced_mode

  fl = $files.size

  # selectedix = nil
  # $patt = ''
  $patt = nil
  $sta = 0
  loop do
    # i = 0
    $view = if $patt
              if $ignorecase
                $files.grep(/#{$patt}/i)
              else
                $files.grep(/#{$patt}/)
              end
            else
              $files
            end
    fl = $view.size
    $sta = 0 if $sta >= fl || $sta < 0
    # 2019-03-18 - added to ensure cursor not going OOB when next_page
    $cursor = 0 if $cursor >= fl || $cursor < 0
    # $sta = $cursor if $sta > $cursor
    $cursor = $sta if $sta > $cursor

    $viewport = $view[$sta, $pagesize]
    fin = $sta + $viewport.size
    $title ||= Dir.pwd.sub(home, '~')
    clear_screen


    # title
    print "#{GREEN}#{$help}  #{BLUE}cetus #{VERSION}#{CLEAR}\n"
    t = "#{$title}  #{$sta + 1} to #{fin} of #{fl}  #{$sorto} F:#{$filterstr}"
    t = t[t.size - $gcols..-1] if t.size >= $gcols
    print "#{BOLD}#{t}#{CLEAR}\n"


    ## nilling the title means a superimposed one gets cleared.
    # $title = nil
    # split into 2 procedures so columnate can e clean and reused.
    buff = _format $viewport

    # break into as many columns as required
    buff = columnate buff, $grows

    # needed the next line to see how much extra we were going in padding
    # buff.each {|line| print "#{REVERSE}#{line}#{CLEAR}\n" }
    buff.each { |line| print line, "\n" }
    print

    # prompt
    # print "#{$files.size}, #{view.size} sta=#{sta} (#{patt}): "
    v_mm = ''
    v_mm = "[#{$mode}] " if $mode
    cf = current_file
    $message = "No file highlighted (#{cf})" if cf and !$highlighted_a_column
    $message = ' | No matches. Press ESCAPE' if $patt && !cf
    # 2019-03-19 - take cursor to last line
    system "tput cup #{$glines} 0"
    # system "tput cup #{$glines} #{$gcols - cfl - 10}"
    print "\e[33;4%sm%*s" % [$status_color || '1', $gcols, " "]

    # sometimes due to search, there is no file
    if cf
      cfl = cf.size
      # print right alighed
      system "tput cup #{$glines} #{$gcols - cfl - 10}"
      # print "#{REVERSE}#{cf}#{CLEAR}"
      print "#{cf}"
    end
    # print "\r#{v_mm}#{$patt} #{GREEN}#{$message}#{CLEAR} >"
    # move to beginning of line, reset text mode after printing
    print "\r#{v_mm}#{$patt}#{$message}\e[m"
    ch = get_char
    $highlighted_a_column = false
    # puts
    # break if ch == "q"
    # elsif  ch =~ /^[1-9a-zA-Z]$/
    # 2019-03-04 - ignore q since that is quit key now
    # if  ch =~ /^[a-zZ]$/
    if ch =~ /^[a-pr-zZ]$/
      # hint mode
      select_hint $viewport, ch
      ctr = 0
    elsif ch == 'BACKSPACE'
      $patt = $patt[0..-2] if $patt && !$patt.empty?
      $message = $patt = nil if $patt == ''
      ctr = 0
    else
      # binding = $bindings[ch]
      x = $bindings[ch]
      x = x.split if x
      if x
        binding = x.shift
        args = x
        send(binding, *args) if binding
      else
        perror "No binding for #{ch}"
      end
      # p ch
    end
    break if $quitting
  end
  write_curdir
  puts 'bye'
  config_write if $writing
end

## write current dir to a file so we can ccd to it when exiting
def write_curdir
  f = File.expand_path('~/.fff_d')
  s = Dir.pwd
  File.open(f, 'w') do |f2|
    f2.puts s
  end
  # puts "Written #{s} to #{f}"
end

## code related to long listing of files
GIGA_SIZE = 1_073_741_824.0
MEGA_SIZE = 1_048_576.0
KILO_SIZE = 1024.0

# Return the file size with a readable style.
# NOTE format is a kernel method.
def readable_file_size(size, precision)
  if size < KILO_SIZE then format('%d B', size)
  elsif size < MEGA_SIZE then format("%.#{precision}f K", (size / KILO_SIZE))
  elsif size < GIGA_SIZE then format("%.#{precision}f M", (size / MEGA_SIZE))
  else format("%.#{precision}f G", (size / GIGA_SIZE))
  end
end

## format date for file given stat
def date_format(t)
  t.strftime '%Y/%m/%d'
end

##
#
# print in columns
# ary - array of data
# sz  - lines in one column
#
def columnate(ary, sz)
  buff = []
  return buff if ary.nil? || ary.empty?

  # 2019-03-19 - just to make sure highlighted column is visible
  $highlighted_a_column = false

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  wid = 30
  ars = ary.size
  ars = [$pagesize, ary.size].min
  d = 0
  if ars <= sz
    wid = $gcols - d
  else
    tmp = (ars * 1.000 / sz).ceil
    wid = $gcols / tmp - d
  end
  # elsif ars < sz * 2
  # wid = $gcols/2 - d
  # elsif ars < sz * 3
  # wid = $gcols/3 - d
  # else
  # wid = $gcols/$gviscols - d
  # end

  # ix refers to the index in the complete file list, wherease we only show 60 at a time
  ix = 0
  loop do
    ## ctr refers to the index in the column
    ctr = 0
    while ctr < sz

      f = ary[ix]
      # f is not just filename but marker and hint
      # Check last char to see if directory
      linecolor = nil
      linecolor = BLUE if f[-1] == '/'

      # check to see if we need to truncate
      # TODO 2019-03-18 - truncate from middle of string.
      fsz = f.size
      if fsz > wid
        fromstart = wid - 8
        # f = f[0, wid - 2] + '$ '
        # 2019-03-18 - trying to truncate from center
        f = f[0, fromstart] + '$' + f[-6..-1] + ' '
        ## we do the coloring after trunc so ANSI escpe seq does not get get
        if ix + $sta == $cursor
          f = "#{CURSOR_COLOR}#{f}#{CLEAR}"
          $highlighted_a_column = true
        elsif linecolor
          f = "#{linecolor}#{f}#{CLEAR}"
        end

      else

        ## we do the coloring before padding so the entire line does not get
        # padded, only file name
        # f = "#{CURSOR_COLOR}#{f}#{CLEAR}" if ix + $sta == $cursor
        if ix + $sta == $cursor
          f = "#{CURSOR_COLOR}#{f}#{CLEAR}"
          $highlighted_a_column = true
        else
          f = "#{linecolor}#{f}#{CLEAR}"  if linecolor
        end
        # f = f.ljust(wid)
        f << ' ' * (wid - fsz)

      end

      # if already a value in that line, append to it
      if buff[ctr]
        buff[ctr] += f
      else
        buff[ctr] = f
      end

      ctr += 1
      ix += 1
      break if ix >= ary.size
    end
    break if ix >= ary.size
  end
  buff
end

## formats the data with number, mark and details
# 2019-03-09 - at some time this got renamed to `format` which is a kernel
#  method and this overshadowed that method.
#  NOTE: this does not do any coloring since the codes may get chopped by
#   columnate method
def _format(ary)
  # buff = Array.new
  buff = Array.new(ary.size)
  return buff if ary.nil? || ary.empty?

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  # ix refers to the index in the complete file list, wherease we only show 60 at a time
  ix = 0
  ctr = 0
  ary.each do |f|
    ## ctr refers to the index in the column
    ind = get_shortcut(ix)
    mark = SPACE
    cur = SPACE
    cur = CURMARK if ix + $sta == $cursor
    mark = GMARK if selected?(ary[ix])

    if $long_listing
      begin
        if File.exist? f
          stat = File.stat(f)
        else
          # remove last character and get stat
          last = f[-1]
          stat = File.stat(f.chop) if last == ' ' || last == '@' || last == '*'
        end
        # this is for saved directories etc which are shortened
        stat ||= File.stat(File.expand_path(f))
        f = format('%10s  %s  %s', readable_file_size(stat.size, 1),
                   date_format(stat.mtime), f)
      rescue Exception => e
        f = format('%10s  %s  %s', '?', '??????????', f)
      end
    end

    s = "#{ind}#{mark}#{cur}#{f}"

    # NOTE: I cannot color the current line since _format does the chopping
    # so not only does the next lines alignment get skewed,
    # but also if the line is truncated
    # then the color overflows.
    # if ix + $sta == $cursor
    # s = "#{RED}#{s}#{CLEAR}"
    # end

    buff[ctr] = s

    ctr += 1
    ix += 1
  end
  buff
end

## select file based on key pressed
def select_hint(view, ch)
  # a to y is direct
  # if x or z take a key IF there are those many
  #
  ix = get_index(ch, view.size)
  return unless ix

  f = view[ix]
  return unless f

  $cursor = $sta + ix

  if $mode == 'SEL'
    toggle_select f
  elsif $mode == 'COM'
    run_command f
  else
    open_file f
  end
  # selectedix=ix
end

## toggle selection state of file
def toggle_select(f=current_file)
  # dir = Dir.pwd
  # file = File.join(dir, f)
  if selected? f
    remove_from_selection f
  else
    add_to_selection f
  end
end

## open file or directory
def open_file(f)
  return unless f

  f = File.expand_path(f) if f[0] == '~'
  unless File.exist? f
    # this happens if we use (T) in place of (M)
    # it places a space after normal files and @ and * which borks commands
    last = f[-1]
    f = f.chop if last == ' ' || last == '@' || last == '*'
  end
  nextpos = nil

  # could be a bookmark with position attached to it
  f, nextpos = f.split(':') if f.index(':')
  if File.directory? f
    save_dir_pos
    change_dir f, nextpos
  elsif File.readable? f
    $default_command ||= '$PAGER'
    if !$editor_mode
      ft = filetype f
      if ft
        comm = $pager_command[ft]
      else
        comm = $pager_command[File.extname(f)]
        comm ||= $pager_command['unknown']
      end
    else
      comm = $default_command
    end
    comm ||= $default_command
    comm = if comm.index('%%')
             comm.gsub('%%', Shellwords.escape(f))
           else
             comm + " #{Shellwords.escape(f)}"
           end
    clear_screen
    reset_terminal
    system(comm.to_s)
    setup_terminal
    f = Dir.pwd + '/' + f if f[0] != '/'
    $visited_files.insert(0, f)
    push_used_dirs Dir.pwd
  else
    perror "open_file: (#{f}) not found"
    # could check home dir or CDPATH env variable DO
  end
end

# regardless of mode, view the current file using pager
def page_current
  command = ENV['MANPAGER'] || ENV['PAGER'] || 'less'
  run_on_current command
end

# regardless of mode, edit the current file using editor
def edit_current
  command = ENV['EDITOR'] || ENV['VISUAL'] || 'vim'
  run_on_current command
  $visited_files.insert(0, current_file)
end

# run given command on current file
def run_on_current(command)
  f = $view[$cursor]
  return unless f
  f = File.expand_path(f)
  return unless File.readable?(f)

  clear_screen
  reset_terminal
  comm = "#{command} #{f}"
  system(comm.to_s)
  push_used_dirs
  setup_terminal
end

## run command on given file/s
#   Accepts command from user
#   After putting readline in place of gets, pressing a C-c has a delayed effect.
#   It goes into exception block after executing other commands and still
#   does not do the return !
def run_command(f)
  files = nil
  case f
  when Array
    # escape the contents and create a string
    files = Shellwords.join(f)
  when String
    files = Shellwords.escape(f)
  end
  print "Run a command on #{files}: "
  begin
    # Readline::HISTORY.push(*values)
    command = Readline.readline('>', true)
    # command = gets().chomp
    return if command.empty?

    print 'Second part of command: '
    # command2 = gets().chomp
    command2 = Readline.readline('>', true)
    puts "#{command} #{files} #{command2}"
    system "#{command} #{files} #{command2}"
  rescue Exception => ex
    perror "Canceled command, (#{ex}) press a key"
    return
  end
  begin
  rescue Exception => ex
  end

  refresh
  puts 'Press a key ...'
  push_used_dirs Dir.pwd
  get_char
end

## cd to a dir and go to position if specified
def change_dir(f, pos = nil)
  unless File.directory? f
    perror "#{p} is not a directory, or does not exist."
    return
  end
  $visited_dirs.insert(0, Dir.pwd)
  save_dir_pos # added 2019-03-20 - so we get to same file
  f = File.expand_path(f)
  Dir.chdir f
  $filterstr ||= 'M'
  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}#{$filterstr})'`.split("\n")
  $files = sort_file_list $files
  post_cd
  if pos
    # convert curpos to sta also
    # $cursor = pos.to_i
    goto_line pos.to_i
  end
end

def goto_previous_dir
  prev_dir = $visited_dirs.first
  return unless prev_dir
  change_dir prev_dir
end

## clear sort order and refresh listing, used typically if you are in some view
#  such as visited dirs or files
def escape
  $sorto = nil
  $sorto = $default_sort_order
  $viewctr = 0
  $title = nil
  $filterstr = 'M'
  $message = nil
  visual_block_clear
  refresh
end

## refresh listing after some change like option change, or toggle
def refresh
  $filterstr ||= 'M'
  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}#{$filterstr})'`.split("\n")
  # first put dirs then files
  $files = sort_file_list $files
  $patt = nil
  $title = nil
end

# put directories first, then files
def sort_file_list(_files)
  _dirs = $files.select { |f| File.directory?(f) }
  _files = $files.select { |f| File.file?(f) }
  _dirs + _files
end

## unselect all files
def unselect_all
  $selected_files = []
  $visual_mode = nil
end

## select all files
def select_all
  dir = Dir.pwd
  $selected_files = $view.map { |file| File.join(dir, file) }
end

## accept dir to goto and change to that ( can be a file too)
def goto_dir
  print 'Enter path: '
  begin
    # path = gets.chomp
    path = Readline.readline('>', true)
    return if path == ''
    # rescue => ex
  rescue Exception => ex
    perror 'Cancelled cd, press a key'
    return
  end
  f = File.expand_path(path)
  unless File.directory? f
    ## check for env variable
    tmp = ENV[path]
    if tmp.nil? || !File.directory?(tmp)
      ## check for dir in home
      tmp = File.expand_path("~/#{path}")
      f = tmp if File.directory? tmp
    else
      f = tmp
    end
  end

  open_file f
end

## toggle mode to selection or not
#  In selection, pressed hotkey selects a file without opening, one can keep selecting
#  (or deselecting).
#
def selection_mode_toggle
  if $mode == 'SEL'
    unselect_all
    $mode = nil
  else
    # $selection_mode = !$selection_mode
    $mode = 'SEL'
  end
end

## toggle command mode
# 2019-03-15 - TODO FIXME preferable when we go into command mode
#  run a command on current or selected files. But then is it a mode, do we remain
#  there, or come out immediately ?
#  2019-03-17 - have removed this altogether. not required
def command_mode
  if $mode == 'COM'
    $mode = nil
    return
  end
  $mode = 'COM'
end

# go to parent dir, and maintain cursor on the dir we came out of
def goto_parent_dir
  # 2019-03-20 - when changing to parent, we need to keep cursor on
  #  parent dir, not first
  curr = File.basename(Dir.pwd)

  change_dir '..'

  # get index of child dir in this dir, and set cursor to it.
  index = $files.index(curr + '/')
  pause "WARNING: Could not find #{curr} in this directory." unless index
  $cursor = index if index
end

def goto_home_dir
  change_dir '~'
end

## This actually filters, in zfm it goes to that entry since we have a cursor there
#
def goto_entry_starting_with(fc = nil)
  unless fc
    print 'Entries starting with: '
    fc = get_char
  end
  return if fc.size != 1

  ## this is wrong and duplicates the functionality of /
  #  It shoud go to cursor of item starting with fc
  $patt = "^#{fc}"
end

# Goes to directory bookmarked with number or upper case char.
# If lower case character given, then go to first file starting with char.
def goto_bookmark(ch = nil)
  unless ch
    print 'Enter bookmark char: '
    ch = get_char
  end
  if ch =~ /^[0-9A-Z]$/
    d = $bookmarks[ch]
    # this is if we use zfm's bookmarks which have a position
    # this way we leave the position as is, so it gets written back
    nextpos = nil
    if d
      if d.index(':')
        ix = d.index(':')
        nextpos = d[ix + 1..-1]
        d = d[0, ix]
      end
      change_dir d, nextpos
    else
      perror "#{ch} not a bookmark"
    end
  else
    # goto_entry_starting_with ch
    file_starting_with ch
  end
end

## take regex from user, to run on files on screen, user can filter file names
def enter_regex
  # print 'Enter (regex) pattern: '
  # move to beginning of line, and clear till EOL
  print "\r\e[K"
  $patt = Readline.readline('/', true)
end

# page/scroll down.
# TODO: 2019-03-18 - cursor needs to be updated
def next_page
  $sta += $pagesize
  $cursor += $pagesize
  $sta = $cursor if $sta > $cursor
  # FIXME this is sometimes correct, but in short  cases, cursor no longer refers
  #  to a file. also after cycling, it no longer has a file.
end

# TODO: 2019-03-18 - cursor needs to be updated
def prev_page
  $sta -= $pagesize
  $cursor -= $pagesize
end

# print help on key-bindings
# 2019-03-08 - write to temp file and user PAGER
def old_print_help
  require 'tempfile'
  file = Tempfile.new('help')
  begin
    file.puts '    HELP'

    file.puts
    file.puts 'To open a file or dir press 1-9 a-z A-Z (on left of file)'
    file.puts 'Ctrl-s to select file under cursor'
    file.puts 'Selection Mode: Each selection adds to selection list (toggles)'
    file.puts '   Execute commands on selected files. e.g D C-x   '
    file.puts '   Upon exiting mode, selection is cleared'
    file.puts 'Use left and right arrows to move through directories'
    file.puts
    ary = []
    $bindings.each_pair { |k, v| ary.push "#{k.ljust(7)}  =>  #{v}" }
    ary = columnate ary, (ary.size/2)+1
    ary.each { |line| file.puts line }
    file.flush
    system "$PAGER #{file.path}"
  rescue
    file.close
    file.unlink
  end
end

def print_help
  page_with_tempfile do |file|
    file.puts '    HELP'

    file.puts
    file.puts 'To open a file or dir press 1-9 a-z A-Z (on left of file)'
    file.puts 'Ctrl-s to select file under cursor'
    file.puts 'Selection Mode: Each selection adds to selection list (toggles)'
    file.puts '   Execute commands on selected files. e.g D C-x   '
    file.puts '   Upon exiting mode, selection is cleared'
    file.puts 'Use left and right arrows to move through directories'
    file.puts
    ary = []
    # TODO: 2019-03-19 -  replace _ with space in value
    # TODO: 2019-03-19 -  if : then show text after colon
    $bindings.each_pair { |k, v| ary.push "#{k.ljust(7)}  =>  #{v}" }
    # FIXME this works but not properly when long_listing is true.
    # We should avoid using columnate as there are several file related things.
    ary = columnate ary, (ary.size/2)+1
    ary.each { |line| file.puts line }
  end
end

def page_stat_for_file
  stat = %x[ stat #{current_file} ]
  return unless stat

  page_with_tempfile do |file|
    file.puts stat
  end

end

def page_with_tempfile
  require 'tempfile'
  file = Tempfile.new('cetus')
  begin
    yield file
    file.flush
    system "$PAGER #{file.path}"
  rescue
    file.close
    file.unlink
  end
end

def debug_vars
  page_with_tempfile do |file|
    file.puts 'DEBUG VARIABLES ARE:'
    file.puts
    file.puts "sta    #{$sta}"
    file.puts "cursor #{$cursor}"
    file.puts "stact  #{$stact}"
    file.puts "viewport.size  #{$viewport.size}"
    file.puts "pagesize       #{$pagesize}"
    file.puts "view.size      #{$view.size}"
    file.puts "file   #{current_file}"
  end
end

def view_bookmarks
  puts
  puts 'Bookmarks: '
  $bookmarks.each_pair { |k, v| puts "#{k.ljust(7)}  =>  #{v}" }
  puts
  print 'Enter bookmark to goto: '
  ch = get_char
  goto_bookmark(ch) if ch =~ /^[0-9A-Z]$/
end

# MENU MAIN -- keep consistent with zfm
def main_menu
  h = {
    :a => :ag,
    '/' => :ffind,
    :l => :locate,
    :V => :viminfo,
    :v => :vidir,
    :z => :z_interface,
    :d => :child_dirs,
    :r => :recent_files,
    '1' => :select_visited_files,
    '2' => :select_used_dirs,
    :t => :dirtree,
    '4' => :tree,
    :s => :sort_menu,
    :F => :filter_menu,
    :c => :command_menu,
    :b => :bookmark_menu,
    :y => :selection_menu,
    :B => :bindkey_ext_command,
    :M => :newdir,
    '%' => :newfile,
    'S' => :scripts,
    :x => :extras
  }
  menu 'Main Menu', h
end

def selection_menu
  h = {
    :a => :select_all,
    :u => :unselect_all,
    :s => :toggle_select,
    '@' => 'selection_mode_toggle',
    'x' => 'visual_mode_toggle',
    :v => :view_selected_files
  }
  menu 'Selection Menu', h
end

def bookmark_menu
  h = {
    :v => :view_bookmarks,
    :c => :create_bookmark,
    :g => :goto_bookmark
  }
  menu 'Bookmark Menu', h
end

# trying out fzf instead
# 2019-03-08 - 23:46
# FIXME returns a String not symbol, so some callers can fail
def fzfmenu(title, h)
  return unless h

  pbold title.to_s
  values = h.values.join("\n")
  binding = `echo "#{values}" | fzf --prompt="#{title.to_s} :"`
  # h.each_pair { |k, v| puts " #{k}: #{v}" }
  # ch = get_char
  # binding = h[ch]
  # binding ||= h[ch.to_sym]
  # FIXME we have converted symbol to string
  ch = nil
  if binding
    binding = binding.chomp
    send(binding) if respond_to?(binding, true)
    ch = h.key(binding)
  end
  [ch, binding]
end

# this style used hotkeys which I remember. But it can get long.
#  and I have to fix a hotkey for each new entry
def menu(title, h)
  return unless h

  pbold title.to_s
  # h.each_pair { |k, v| puts " #{k}: #{v}" }
  # 2019-03-09 - trying out using `column` to print in cols
  ary = []
  h.each_pair { |k, v| ary << " #{k}: #{v}" }
  x = ary.join("\n")
  puts %x{echo "#{x}" | column}

  ch = get_char
  binding = h[ch]
  binding ||= h[ch.to_sym]
  if binding
    send(binding) if respond_to?(binding, true)
  end
  [ch, binding]
end

def toggle_menu
  h = { :h => :toggle_hidden, :c => :toggle_case, :l => :toggle_long_list, '1' => :toggle_columns,
        :p => :toggle_pager_mode, :e => :toggle_enhanced_list }
  _, menu_text = menu 'Toggle Menu', h
  # NOTE fzfmenu returns string not symbol
  return unless menu_text

  case menu_text
  when :toggle_hidden
    $hidden = $hidden ? nil : 'D'
    pause "Show hidden files is now #{!$hidden.nil?}"
    message "Show hidden is now #{!$hidden.nil?}"
    refresh
  when :toggle_case
    # $ignorecase = $ignorecase ? "" : "i"
    $ignorecase = !$ignorecase
    pause "Ignore Case is now #{$ignorecase}"
    message "Ignore Case is now #{$ignorecase}"
    refresh
  when :toggle_columns
    $gviscols = 3 if $gviscols == 1
    # $long_listing = false if $gviscols > 1
    x = $grows * $gviscols
    $pagesize = $pagesize == x ? $grows : x
    pause "Visible columns now set to #{$gviscols}"
  when :toggle_pager_mode
    $editor_mode = !$editor_mode
    $default_command = if $editor_mode
                         ENV['EDITOR'] # earlier nil # 2019-03-10 -
                         # it was nil so we could set a default command
                       else
                         ENV['MANPAGER'] || ENV['PAGER']
                       end
    message "Default command is #{$default_command}"
  when :toggle_enhanced_list
    $enhanced_mode = !$enhanced_mode
    message "Enhanced mode is #{$long_listing}"

  when :toggle_long_list
    $long_listing = !$long_listing
    if $long_listing
      $gviscols = 1
      $pagesize = $grows
    else
      x = $grows * $gviscols
      $pagesize = $pagesize == x ? $grows : x
    end
    message "Long listing is #{$long_listing}"
    refresh
  end
end

def sort_menu
  lo = nil
  h = { n: :newest, a: :accessed, o: :oldest,
        l: :largest, s: :smallest, m: :name, r: :rname, d: :dirs, c: :clear }
  ch, menu_text = menu 'Sort Menu', h
  case menu_text
  when :newest
    lo = 'om'
  when :accessed
    lo = 'oa'
  when :oldest
    lo = 'Om'
  when :largest
    lo = 'OL'
  when :smallest
    lo = 'oL'
  when :name
    lo = 'on'
  when :rname
    lo = 'On'
  when :dirs
    lo = '/'
  when :clear
    lo = ''
  end
  ## This needs to persist and be a part of all listings, put in change_dir.
  $sorto = lo
  $files = `zsh -c 'print -rl -- *(#{lo}#{$hidden}M)'`.split("\n") if lo
  $title = nil
  # $files =$(eval "print -rl -- ${pattern}(${MFM_LISTORDER}$filterstr)")
end

# thse need to be placed in correct position, some do nothing
#  and some like ffind have no menu item
def command_menu
  #  since these involve full paths, we need more space, like only one column
  ## in these cases, getting back to the earlier dir, back to earlier listing
  # since we've basically overlaid the old listing
  # should be able to sort THIS listing and not rerun command. But for that I'd need to use
  # xargs ls -t etc rather than the zsh sort order. But we can run a filter using |.
  #
  h = { t: :today, D: :default_command, R: :remove_from_list,
        v: :view_selected_files }
  h[:e] = if $editor_mode
            :pager_mode
          else
            :editor_mode
          end
  _, menu_text = menu 'Command Menu', h
  case menu_text
  when :pager_mode
    $editor_mode = false
    $default_command = ENV['MANPAGER'] || ENV['PAGER']
  when :editor_mode
    $editor_mode = true
    $default_command = nil
  when :ffind
    ffind
  when :locate
    locate
  when :today
    $files = `zsh -c 'print -rl -- *(#{$hidden}Mm0)'`.split("\n")
    $title = "Today's files"
  when :default_command
    puts " THis no longer works"
    puts 'Selecting a file usually invokes $EDITOR'
    puts 'What command do you want to use repeatedly on selected files: '
    $default_command = gets.chomp
    if $default_command != ''
      print 'Second part of command (maybe blank): '
      $default_command2 = gets.chomp
    else
      print 'Cleared default command, will default to $EDITOR'
      $default_command2 = nil
      $default_command = nil
    end
  end
end

# This is quite badly placed and named. Maybe these should go elsewhere
def extras
  h = { '1' => :one_column, '2' => :multi_column, :c => :columns, :r => :config_read, :w => :config_write }
  ch, menu_text = menu 'Extras Menu', h
  case menu_text
  when :one_column
    $pagesize = $grows
  when :multi_column
    # $pagesize = 60
    $pagesize = $grows * $gviscols
  when :columns
    print "How many columns to show: 1-6 [current #{$gviscols}]? "
    ch = get_char
    ch = ch.to_i
    if ch > 0 && ch < 7
      $gviscols = ch.to_i
      $pagesize = $grows * $gviscols
    end
  end
end

def filter_menu
  h = { :d => :dirs, :f => :files, :e => :emptydirs, '0' => :emptyfiles,
  :r => :reduce_list, :x => :extension}
  ch, menu_text = menu 'Filter Menu', h
  files = nil
  case menu_text
  when :dirs
    $filterstr = '/M'
    files = `zsh -c 'print -rl -- *(#{$sorto}/M)'`.split("\n")
    $title = 'Filter: directories only'
  when :files
    $filterstr = '.'
    files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}.)'`.split("\n")
    $title = 'Filter: files only'
  when :emptydirs
    $filterstr = '/D^F'
    files = `zsh -c 'print -rl -- *(#{$sorto}/D^F)'`.split("\n")
    $title = 'Filter: empty directories'
  when :emptyfiles
    $filterstr = '.L0'
    files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}.L0)'`.split("\n")
    $title = 'Filter: empty files'
  when :reduce_list
    files = reduce
  when :extension
    files = filter_for_current_extension
  end
  if files
    $files = files
    $stact = 0
  end
end

def reduce pattern=nil
  unless pattern
    print 'Enter a pattern to reduce current list: '
    pattern = gets.chomp
  end
  $title = "Filter: pattern #{pattern}"
  $files = $files.select {|f| f.match(pattern)}
end

def filter_for_current_extension
  extn = File.extname(current_file)
  return unless extn
  reduce extn
end

def select_used_dirs
  $title = 'Used Directories'
  home = File.expand_path '~'
  $files = $used_dirs.uniq.map { |path| path.sub("#{home}", '~') }
end

def select_visited_files
  # not yet a unique list, needs to be unique and have latest pushed to top
  $title = 'Visited Files'
  home = File.expand_path '~'
  $files = $visited_files.uniq.map { |path| path.sub("#{home}", '~') }
end

def select_bookmarks
  $title = 'Bookmarks'
  $files = $bookmarks.values
end

## part copied and changed from change_dir since we don't dir going back on top
#  or we'll be stuck in a cycle
def pop_dir
  # the first time we pop, we need to put the current on stack
  $visited_dirs.push Dir.pwd unless $visited_dirs.index(Dir.pwd)
  ## XXX make sure thre is something to pop
  d = $visited_dirs.delete_at 0
  ## XXX make sure the dir exists, cuold have been deleted. can be an error or crash otherwise
  $visited_dirs.push d
  Dir.chdir d
  $filterstr ||= 'M'
  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}#{$filterstr})'`.split("\n")
  $files = sort_file_list $files
  post_cd
end

# after changing directory
def post_cd
  $patt = nil
  $sta = $cursor = 0
  $title = nil
  $message = nil
  $visual_block_start = nil
  $stact = 0
  $current_dir = Dir.pwd # 2019-03-10 - so i don't keep doing in functions
  screen_settings
  # i think this will screw with the dir_pos since it is not filename based.
  enhance_file_list
  ## added by RK 2014-03-31 - 00:29 since too many duplicates
  $files = $files.uniq if $enhanced_mode
  revert_dir_pos
end

## read dirs and files and bookmarks from file
def config_read
  # f =  File.expand_path("~/.zfminfo")
  f = File.expand_path(CONFIG_FILE)
  return unless File.readable? f

  hash = loadYML(f)
  $used_dirs = hash['DIRS']
  $visited_files = hash['FILES']
  $bookmarks = hash['BOOKMARKS']
  $used_dirs.concat get_env_paths
end

def get_env_paths
  files = []
  %w[GEM_HOME PYTHONHOME].each do |p|
    d = ENV[p]
    files.push d if d
  end
  %w[RUBYLIB RUBYPATH GEM_PATH PYTHONPATH].each do |p|
    d = ENV[p]
    files.concat d.split(':') if d
  end
  files
end

## save dirs and files and bookmarks to a file
# - moved to yml 2019-03-09
def config_write
  # Putting it in a format that zfm can also read and write
  f1 = File.expand_path(CONFIG_FILE)
  hash = {}
  hash['DIRS'] = $used_dirs.select {|dir| File.exist? dir}
  hash['FILES'] = $visited_files.select {|file| File.exist? file}
  # NOTE bookmarks is a hash and contains FILE:cursor_pos
  hash['BOOKMARKS'] = $bookmarks #.select {|file| File.exist? file}
  writeYML hash, f1
  $writing = $modified = false
  message "Saved #{f1}"
end

# {{{ YML
require 'yaml'
def loadYML( filename)
  hash = YAML::load( File.open( filename ) )
  if $opt_debug
    $stderr.puts hash.keys.size
  end
  return hash
end
def writeYML obj, filename
  File.open(filename, 'w') {|f| f.write obj.to_yaml }
  if $opt_debug
    $stderr.puts "Written to file #{filename}"
  end
end
# }}}

## accept a character to save this dir as a bookmark
def create_bookmark
  print 'Enter A to Z or 0-9 to create a bookmark: '
  ch = get_char
  if ch =~ /^[0-9A-Z]$/
    # $bookmarks[ch] = "#{Dir.pwd}:#{$cursor}"
    $bookmarks[ch] = Dir.pwd
    $modified = true
    message "Created bookmark #{ch}"
  else
    perror 'Bookmark must be upper-case character or number.'
  end
end

# allow user to exit using :q :wq :x
# Was this supposed to be augmented, or just remain limited like this
# We should be able to do everything in the menus from here. TODO
def subcommand
  print 'Enter command: q x wq p w e r h '
  begin
    command = Readline.readline('>', true)
    return if command == ''
  rescue Exception => ex
    return
  end
  if command == 'q'
    if $modified
      print 'Do you want to save bookmarks? (y/n): '
      ch = get_char
      if ch == 'y'
        $writing = true
        $quitting = true
      elsif ch == 'n'
        $quitting = true
        print 'Quitting without saving bookmarks'
      else
        perror 'No action taken.'
      end
    else
      $quitting = true
    end
  elsif command == 'wq'
    $quitting = true
    $writing = true
  elsif command == 'w'
    config_write
  elsif command == 'x'
    $quitting = true
    $writing = true if $modified
  elsif command == 'e'
    edit_current
  elsif command == 'h' or command == 'help' or command == '?'
    print_help
  elsif command == 'p'
    system 'echo $PWD | pbcopy'
    puts 'Stored PWD in clipboard (using pbcopy)'
  else
    perror "Don't know about command #{command}. Try :h or :help"
  end
end

def quit_command
  if $modified
    puts 'Press w to save bookmarks before quitting ' if $modified
    print 'Press another q to quit '
    ch = get_char
  else
    $quitting = true
  end
  $quitting = true if ch == 'q'
  $quitting = $writing = true if ch == 'w'
end

def views
  views = %w[/ om oa Om OL oL On on]
  viewlabels = %w[Dirs Newest Accessed Oldest Largest Smallest Reverse Name]
  $sorto = views[$viewctr]
  $title = viewlabels[$viewctr]
  $viewctr += 1
  $viewctr = 0 if $viewctr > views.size

  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}M)'`.split("\n")
end

def child_dirs
  $title = 'Child directories'
  $files = `zsh -c 'print -rl -- *(/#{$sorto}#{$hidden}M)'`.split("\n")
end

def dirtree
  $title = 'Child directories'
  $files = `zsh -c 'print -rl -- **/*(/#{$sorto}#{$hidden}M)'`.split("\n")
end

#
# Get a full recursive listing of what's in this dir - useful for small projects with more
# structure than files.
def tree
  # Caution: use only for small projects, don't use in root.
  $title = 'Full Tree'
  $files = `zsh -c 'print -rl -- **/*(#{$sorto}#{$hidden}M)'`.split("\n")
end

# lists recent files in current dir
# In some cases it shows mostly .git files, we need to prune those
def recent_files
  # print -rl -- **/*(Dom[1,10])
  $title = 'Recent files'
  $files = `zsh -c 'print -rl -- **/*(Dom[1,15])'`.split("\n").reject {|f| f[0] == '.'}
end

def select_current
  ## vp is local there, so i can do $vp[0]
  # open_file $view[$sta] if $view[$sta]
  open_file $view[$cursor] if $view[$cursor]
end

## create a list of dirs in which some action has happened, for saving
def push_used_dirs(d = Dir.pwd)
  # $used_dirs.index(d) || $used_dirs.push(d)
  return if $used_dirs[0] == d
  $used_dirs.delete(d) if $used_dirs.index(d)
  $used_dirs.insert(0, d)
end

def pbold(text)
  puts "#{BOLD}#{text}#{BOLD_OFF}"
end

def perror(text)
  puts "#{RED}#{text}#{CLEAR}"
  get_char
end

def pause(text = ' Press a key ...')
  print text
  get_char
end

## return shortcut for an index (offset in file array)
# use 2 more arrays to make this faster
#  if z or Z take another key if there are those many in view
#  Also, display ROWS * COLS so now we are not limited to 60.
def get_shortcut(ix)
  return '<' if ix < $stact

  ix -= $stact
  i = $IDX[ix]
  return i if i

  '->'
end

## returns the integer offset in view (file array based on a-y za-zz and Za - Zz
# Called when user types a key
#  should we even ask for a second key if there are not enough rows
#  What if we want to also trap z with numbers for other purposes
def get_index(key, vsz = 999)
  i = $IDX.index(key)
  return i + $stact if i

  # sz = $IDX.size
  zch = nil
  if vsz > 25
    if key == 'z' || key == 'Z'
      print key
      zch = get_char
      print zch
      i = $IDX.index("#{key}#{zch}")
      return i + $stact if i
    end
  end
  nil
end

def delete_file
  file_actions :delete
end

## generic external command program
#  prompt is the user friendly text of command such as list for ls, or extract for dtrx, page for less
#  pauseyn is whether to pause after command as in file or ls
#
def command_file(prompt, *command)
  pauseyn = command.shift
  command = command.join ' '
  print "[#{prompt}] Choose a file [#{$view[$cursor]}]: "
  file = ask_hint $view[$cursor]
  # print "#{prompt} :: Enter file shortcut: "
  # file = ask_hint
  perror 'Command Cancelled' unless file
  return unless file

  file = File.expand_path(file)
  if File.exist? file
    file = Shellwords.escape(file)
    pbold "#{command} #{file} (#{pauseyn})"
    system "#{command} #{file}"
    pause if pauseyn == 'y'
    refresh
  else
    perror "File #{file} not found"
  end
end

## prompt user for file shortcut and return file or nil
#
def ask_hint(deflt = nil)
  f = nil
  ch = get_char
  return deflt if ch == 'ENTER'

  ix = get_index(ch, $viewport.size)
  f = $viewport[ix] if ix
  f
end

## check screen size and accordingly adjust some variables
#
def screen_settings
  $glines = `tput lines`.to_i
  $gcols = `tput cols`.to_i
  $grows = $glines - 3
  # $pagesize = 60
  # $gviscols = 3
  $pagesize = $grows * $gviscols
end

## moves column offset so we can reach unindexed columns or entries
# 0 forward and any other back/prev
# direction is 0 (forward) or 1 (backward)
# TODO 2019-03-18 - $cursor should also move
def column_next(direction = 0)
  # right movement or panning cycles back to first column
  # leftward movement stops at first column.
  if direction == 0
    $stact += $grows
    $stact = 0 if $stact >= $viewport.size
    $cursor += $grows
    # 2019-03-18 - zero loses offset. we need to maintain it
    # $cursor = 0 if $cursor >= $viewport.size
    if $cursor >= $viewport.size
      while $cursor > 0
        $cursor -= $grows
      end
      $cursor += $grows if $cursor < 0
    end
  else
    $stact -= $grows
    $cursor -= $grows
    $stact = 0 if $stact < 0
    # setting cursor as zero loses the position or offset
    # We are trying to maintain offset
    $cursor += $grows if $cursor < 0
  end
end

# currently i am only passing the action in from the list there as a key
# I should be able to pass in new actions that are external commands
# 2019-03-08 - TODO when a file name changes or moves it must be removed
#  from selection
def file_actions(action = nil)
  # only add dtrx for gz
  h = { d: :delete, m: :move, r: :rename, v: ENV['EDITOR'] || :vim,
        c: :copy, C: :chdir, W: :remspace, e: :execute, s: :page_stat_for_file,
        l: :less, p: :most, f: :file, o: :open, x: :dtrx, z: :zip }
  # acttext = h[action.to_sym] || action
  acttext = action || ''
  file = nil

  sct = $selected_files.size
  if sct > 0
    text = "#{sct} files"
    file = $selected_files
  else
    # 2019-03-07 - trying out direct deletes
    # why were we aksing to select a file when user is on a file
    # print "[#{acttext}] Choose a file [#{$view[$cursor]}]: "
    # file = ask_hint $view[$cursor]
    file = $view[$cursor]
    unless file
      file = ask_hint $view[$cursor]
    end
    return unless file

    text = file
  end
  # 2019-03-07 - NOTE at this point file can be one or more files.
  # 2019-03-07 - text can be a file or count of files, so unreliable !!! FIXME

  case file
  when Array
    # escape the contents and create a string
    files = Shellwords.join(file)
  when String
    files = Shellwords.escape(file)
  end

  ch = nil
  if action
    menu_text = action
  else
    ch, menu_text = menu "File Menu for #{text}", h
    menu_text = :quit if ch == 'q'
  end
  return unless menu_text # pressed some wrong key

  case menu_text.to_sym

  when :quit

  when :delete
    delcommand = 'rmtrash'
    print "#{delcommand} #{text} ?[yn?]: "
    ch = get_char
    view_selected_files if ch == '?'
    return if ch != 'y'

    system "#{delcommand} #{files}"
    refresh

  when :move
    # 2019-03-07 - NOTE this will only work with single file selection
    print "move #{text} to : "
    # target = gets().chomp
    # target = Readline.readline('>', true)
    target = readline
    return unless target

    target = '.' if target == ''
    # 2019-03-07 - NOTE cannot use text if multiple files
    # text = File.expand_path(text)
    target = File.expand_path(target)
    return if target == ''

    if File.directory? target
      begin
        FileUtils.mv file, target
        message "Moved #{text} to #{target}"
      rescue StandardError => exc
        perror exc.to_s
      end
      # 2019-03-08 - TODO if success remove from selection
      refresh
    else
      perror 'Target not a dir'
    end

  when :copy
    # Target must be directory
    print "copy #{text} to : "
    target = readline
    return unless target # C-c

    target = '.' if target == ''
    target = File.expand_path(target)
    return if target == ''

    if File.directory? target
      begin
        FileUtils.cp file, target
        message "Copied #{text} to #{target}"
      rescue StandardError => exc
        perror exc.to_s
      end
      refresh
    else
      perror 'Copy target must be a dir'
    end

  when :chdir
    change_dir File.dirname(text)

  when :zip
    print 'Archive name: '
    # target = gets().chomp
    target = Readline.readline('>', true)
    return if target == ''

    # don't want a blank space or something screwing up
    if target && target.size > 3
      if File.exist? target
        perror "Target (#{target}) exists"
      else
        system "tar zcvf #{target} #{files}"
        refresh
      end
    end

  when :rename
    # 2019-03-07 NOTE works for single file FIXME
    # 2019-03-07 - TODO for n files replace pattern with string
    print "rename #{text} to : "
    target = Readline.readline('>', true)
    return if target == ''

    text = File.expand_path(text)
    target = File.basename(text) if target == '.'
    if File.exist? target
      perror "Target (#{target}) exists"
    else
      FileUtils.mv text, target
      refresh
    end
  when :most, :less, :vim
    system "#{menu_text} #{files}"
    # should we remove from selection ?

  when :remspace
    # 2019-03-08 - 00:07 added replace space with underscore in filename
    print "Remove spaces from #{file}"
    pause
    farray = nil

    # stupidly using one variable for scalar and array DUH !
    case file
    when String
      farray = [file]
    when Array
      farray = file
    end

    farray.each do |f|
      if f.index ' '
        nname = f.tr(' ', '_')
        FileUtils.mv f, nname unless File.exist? nname
        # if success then remove from selection
      end
    end
    refresh
  when :execute
    execute
  when :page_stat_for_file
    1
    # already been executed by menu
    # We could have just put 'stat' in the menu but that doesn't look so nice
  else
    return unless menu_text

    print "#{menu_text} #{files}"
    pause
    print
    system "#{menu_text} #{files}"
    refresh
    pause
  end

  # remove non-existent files from select list due to move or delete
  #  or rename or whatever
  if sct > 0
    $selected_files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  end
end

# increase or decrease column
def columns_incdec(howmany)
  $gviscols += howmany.to_i
  $gviscols = 1 if $gviscols < 1
  $gviscols = 6 if $gviscols > 6
  $pagesize = $grows * $gviscols
end

# bind a key to an external command wich can be then be used for files
def bindkey_ext_command
  print
  pbold 'Bind a capital letter to an external command'
  print 'Enter a capital letter to bind: '
  ch = get_char
  return if ch == 'Q'

  if ch =~ /^[A-Z]$/
    print "Enter an external command to bind to #{ch}: "
    com = gets.chomp
    if com != ''
      print 'Enter prompt for command (blank if same as command): '
      pro = gets.chomp
      pro = com if pro == ''
    end
    print 'Pause after output [y/n]: '
    yn = get_char
    $bindings[ch] = "command_file #{pro} #{yn} #{com}"
  end
end

# execute a command on selected or current file
def execute
  if $selected_files.empty?
    run_command current_file
    return
  end
  run_command $selected_files
end

def ag
  print 'Enter a pattern to search (ag): '
  pattern = Readline.readline('>', true)
  return if pattern == ''

  $title = "Files found using 'ag' #{pattern}"
  system("ag #{pattern}")
  pause
  files = `ag -l #{pattern}`.split("\n")
  if files.empty?
    perror 'No files found for #{pattern}.'
    return
  end
  $files = files
end

def ffind
  print 'Enter a file name pattern to find: '
  pattern = Readline.readline('>', true)
  return if pattern == ''

  $title = "Files found using 'find' #{pattern}"
  files = `find . -name "#{pattern}"`.split("\n")
  if files.empty?
    perror 'No files found. Try adding *'
  else
    $files = files
  end
end

def locate
  print 'Enter a file name pattern to locate: '
  pattern = Readline.readline('>', true)
  return if pattern == ''

  $title = "Files found using 'locate' #{pattern}"
  files = `locate #{pattern}`.split("\n")
  files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  if files.empty?
    perror 'No files found.'
  else
    $files = files
  end
end

## Displays files from .viminfo file, if you use some other editor which
# tracks files opened then you can modify this accordingly.
# Neovim does not use viminfo
#
def viminfo
  file = File.expand_path('~/.viminfo')
  if File.exist? file
    $title = 'Files from ~/.viminfo'
    # $files = `grep '^>' ~/.viminfo | cut -d ' ' -f 2- | sed "s#~#$HOME#g"`.split("\n")
    $files = `grep '^>' ~/.viminfo | cut -d ' ' -f 2- `.split("\n")
    $files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  end
end

##  takes directories from the z program, if you use autojump you can
#   modify this accordingly
#
def z_interface
  file = File.expand_path('~/.z')
  if File.exist? file
    $title = 'Directories from ~/.z'
    $files = `sort -rn -k2 -t '|' ~/.z | cut -f1 -d '|'`.split("\n")
    home = ENV['HOME']
    # shorten file names
    $files.collect! do |f|
      f.sub(/#{home}/, '~')
    end
  end
end

def vidir
  system "vidir"
end
## there is no one consisten way i am getting.
#  i need to do a shell join if I am to pipe ffiles to say: xargs ls -t
#  but if i want to pipe names to grep xxx then i need to join with newlines
def pipe; end

## some cursor movement functions
# TODO: 2019-03-18 - cursor should also be updated
# sta is not updated when cursor > viewport.size and sta is still 0
def cursor_scroll_dn
  moveto(pos + MSCROLL)
end

# TODO: 2019-03-18 - cursor should also be updated
def cursor_scroll_up
  moveto(pos - MSCROLL)
end

# TODO: 2019-03-18 - cursor and sta should also be updated if page changes
def cursor_dn
  moveto(pos + 1)
end

# TODO: 2019-03-18 - cursor and sta should also be updated if page changes
def cursor_up
  moveto(pos - 1)
end

def pos
  $cursor
end

# move cursor to given position/line
# $sta should also move
def moveto(position)
  orig = $cursor
  $cursor = position
  $cursor = [$cursor, $view.size - 1].min
  $cursor = [$cursor, 0].max
  # 2019-03-18 - adding sta
  # $sta = position - only when page flips and file not visible
  # FIXME not correct, it must stop at end or correctly cycle
  # sta goes to 0 but cursor remains at 70
  # viewport.size may be wrong here, maybe should be pagesize only
  if $cursor - $sta >= $pagesize
    $sta += $pagesize
  # elsif $sta - $cursor >= $viewport.size
  end
  if $sta > $cursor
    $sta -= $pagesize
    # $sta = $cursor
  end

  star = [orig, $cursor].min
  fin = [orig, $cursor].max
  return unless $visual_mode

  # PWD has to be there in selction
  if selected? current_file
    # this depends on the direction
    # $selected_files = $selected_files - $view[star..fin]
    remove_from_selection $view[star..fin]
    ## current row remains in selection always.
    add_to_selection current_file
  else
    # $selected_files.concat $view[star..fin]
    add_to_selection $view[star..fin]
  end
end

# is given file in selected array
def selected?(file)
  $current_dir ||= Dir.pwd
  file = File.join($current_dir, file)
  return $selected_files.index file
end

# TODO: can be array
def add_to_selection(file)
  ff = file
  case file
  when String
    ff = [file]
  end
  $current_dir ||= Dir.pwd
  ff.each do |f|
    full = File.join($current_dir, f)
    $selected_files.push(full) unless $selected_files.include?(full)
  end
end

# TODO: can be array
def remove_from_selection(file)
  ff = file
  case file
  when String
    ff = [file]
  end
  $current_dir ||= Dir.pwd
  ff.each do |f|
    full = File.join($current_dir, f)
    $selected_files.delete full
  end
end

def visual_mode_toggle
  $mode = nil
  $visual_mode = !$visual_mode
  if $visual_mode
    $mode = 'VIS'
    $visual_block_start = $cursor
    add_to_selection current_file
  end
end

def visual_block_clear
  if $visual_block_start
    star = [$visual_block_start, $cursor].min
    fin = [$visual_block_start, $cursor].max
    remove_from_selection $view[star..fin]
  end
  $visual_block_start = nil
  $visual_mode = nil
end

def file_starting_with(first_char)
  ix = return_next_match(method(:file_matching?), "^#{first_char}")
  goto_line ix if ix
end

def file_matching?(file, patt)
  file =~ /#{patt}/
end

## generic method to take cursor to next position for a given condition
def return_next_match(binding, *args)
  first = nil
  ix = 0
  $view.each_with_index do |elem, ii|
    next unless binding.call(elem, *args)

    first ||= ii
    if ii > $cursor
      ix = ii
      break
    end
  end
  return first if ix == 0

  ix
end

##
# position cursor on a specific line which could be on a nother page
# therefore calculate the correct start offset of the display also.
def goto_line(pos)
  pages = ((pos * 1.00) / $pagesize).ceil
  pages -= 1
  $sta = pages * $pagesize + 1
  $cursor = pos
end

def filetype(f)
  return nil unless f

  f = Shellwords.escape(f)
  s = `file #{f}`
  if s.index 'text'
    return :text
  elsif s.index(/[Zz]ip/)
    return :zip
  elsif s.index('archive')
    return :zip
  elsif s.index 'image'
    return :image
  elsif s.index 'data'
    return :text
  end

  nil
end

# save offset in directory so we can revert to it when we return
def save_dir_pos
  # the next line meant that it would not save first directory.
  # return if $sta == 0 && $cursor == 0

  $dir_position[Dir.pwd] = [$sta, $cursor]
end

# revert to the position we were at in this directory
def revert_dir_pos
  $sta = 0
  $cursor = 0
  a = $dir_position[Dir.pwd]
  if a
    $sta = a.first
    $cursor = a[1]
    raise "sta is nil for #{Dir.pwd} : #{$dir_position[Dir.pwd]}" unless $sta
    raise 'cursor is nil' unless $cursor
  end
end

def newdir
  print
  print 'Enter directory name: '
  str = Readline.readline('>', true)
  return if str == ''

  if File.exist? str
    perror "#{str} exists."
    return
  end
  begin
    FileUtils.mkdir str
    $used_dirs.insert(0, str) if File.exist?(str)
    refresh
  rescue Exception => ex
    perror "Error in newdir: #{ex}"
  end
end

def newfile
  print
  print 'Enter file name: '
  str = Readline.readline('>', true)
  return if str == ''

  # FIXME a file with space will not create single file
  # 2019-03-10 - maybe touch a file

  system %($EDITOR "#{str}")
  $visited_files.insert(0, str) if File.exist?(str)
  refresh
end

# convenience method to return file under cursor
def current_file
  $view[$cursor]
end

def current_or_selected_files
  return $selected_files if $selected_files.size > 0

  return [current_file]
end

# ------------------- scripts ------------------ #
# prompt for scripts to execute, giving selected file names
def scripts
  title = 'Select a script'
  script_path = '~/.config/cetus/scripts'
  binding = `find #{script_path} -type f | fzf --prompt="#{title.to_s} :"`
  return unless binding

  binding = binding.chomp if binding
  # TODO: check if binding is a file and executable
  # xargs only seems to take the first file
  # cf = current_or_selected_files.join('\0')
  # cf = Shellwords.join(current_or_selected_files)
  current_or_selected_files.each do |file|
    system %( #{binding} "#{file}" )
  end
  # system %(echo "#{cf}" | xargs #{binding})
  pause
end
# ------------- end of scripts --------------------------------#

# ------------------- view_selected_files ------------------ #
def view_selected_files
  require 'tempfile'
  file = Tempfile.new('selected_files')
  begin
    $selected_files.each { |row| file.puts row }
    file.flush
    system "$PAGER #{file.path}"
  rescue
    file.close
    file.unlink
  end
end
# ------------- end of view_selected_files --------------------------------#
##
# Editing of the User Dir List.
# remove current entry from used dirs list, since we may not want some entries being there
#
def remove_from_list
  unless $selected_files.empty?
    sz = $selected_files.size
    print "Remove #{sz} files from used list (y)?: "
    ch = get_char
    return if ch != 'y'

    arr = $selected_files.map { |path| File.expand_path(path) }

    $used_dirs = $used_dirs - arr
    $visited_files = $visited_files - arr
    unselect_all
    $modified = true
    refresh
    return
  end
  print
  ## what if selected some rows
  file = $view[$cursor]
  print "Remove #{file} from used list (y)?: "
  ch = get_char
  return if ch != 'y'

  file = File.expand_path(file)
  if File.directory? file
    $used_dirs.delete(file)
  else
    $visited_files.delete(file)
  end
  refresh
  $modified = true
end

#
# If there's a short file list, take recently mod and accessed folders and put latest
# files from there and insert it here. I take both since recent mod can be binaries / object
# files and gems created by a process, and not actually edited files. Recent accessed gives
# latest source, but in some cases even this can be misleading since running a program accesses
# include files.
def enhance_file_list
  return unless $enhanced_mode

  # if only one entry and its a dir
  # get its children and maybe the recent mod files a few

  if $files.size == 1
    # its a dir, let give the next level at least
    if $files.first[-1] == '/'
      d = $files.first
      f = `zsh -c 'print -rl -- #{d}*(omM)'`.split("\n")
      if f && !f.empty?
        $files.concat f
        $files.concat get_important_files(d)
        return
      end
    else
      # just a file, not dirs here
      return
    end
  end
  #
  # check if a ruby project dir, although it could be a backup file too,
  # if so , expand lib and maby bin, put a couple recent files
  #
  if $files.index('Gemfile') || !$files.grep(/\.gemspec/).empty?
    # usually the lib dir has only one file and one dir
    flg = false
    $files.concat get_important_files(Dir.pwd)
    if $files.index('lib/')
      f = `zsh -c 'print -rl -- lib/*(om[1,5]M)'`.split("\n")
      if f && !f.empty?
        insert_into_list('lib/', f)
        flg = true
      end
      dd = File.basename(Dir.pwd)
      if f.index("lib/#{dd}/")
        f = `zsh -c 'print -rl -- lib/#{dd}/*(om[1,5]M)'`.split("\n")
        if f && !f.empty?
          insert_into_list("lib/#{dd}/", f)
          flg = true
        end
      end
    end
    if $files.index('bin/')
      f = `zsh -c 'print -rl -- bin/*(om[1,5]M)'`.split("\n")
      insert_into_list('bin/', f) if f && !f.empty?
      flg = true
    end
    return if flg

    # lib has a dir in it with the gem name

  end
  return if $files.size > 15

  ## first check accessed else modified will change accessed
  moda = `zsh -c 'print -rn -- *(/oa[1]M)'`
  if moda && moda != ''
    modf = `zsh -c 'print -rn -- #{moda}*(oa[1]M)'`
    insert_into_list moda, modf if modf && modf != ''
    modm = `zsh -c 'print -rn -- #{moda}*(om[1]M)'`
    insert_into_list moda, modm if modm && modm != '' && modm != modf
  end
  ## get last modified dir
  modm = `zsh -c 'print -rn -- *(/om[1]M)'`
  if modm != moda
    modmf = `zsh -c 'print -rn -- #{modm}*(oa[1]M)'`
    insert_into_list modm, modmf
    modmf1 = `zsh -c 'print -rn -- #{modm}*(om[1]M)'`
    insert_into_list(modm, modmf1) if modmf1 != modmf
  else
    # if both are same then our options get reduced so we need to get something more
    # If you access the latest mod dir, then come back you get only one, since mod and accessed
    # are the same dir, so we need to find the second modified dir
  end
end

def insert_into_list(_dir, file)
  # ix = $files.index(dir)
  # raise "something wrong can find #{dir}." unless ix
  # $files.insert ix, *file
  # 2013-03-19 - 19:42 adding at end to avoid confusion
  # $files.concat file
  $files.push *file
end

def get_important_files(dir)
  # checks various lists like visited_files and bookmarks
  # to see if files from this dir or below are in it.
  # More to be used in a dir with few files.
  list = []
  l = dir.size + 1
  $visited_files.each do |e|
    list << e[l..-1] if e.index(dir) == 0
  end
  # bookmarks have : which needs to be removed
  # list1 = $bookmarks.values.select do |e|
  # e.index(dir) == 0
  # end
  # list.concat list1
  list
end

def message mess
  $message = mess
end

Signal.trap('EXIT') do
  reset_terminal
  # system 'tput rmcup'
  exit
end
run
# 2019-02-20 - added so alt-screen is used
system 'tput rmcup'
