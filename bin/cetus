#!/usr/bin/env ruby
# --------------------------------------------------------------------------- #
#         File: cetus
#  Description: Fast file navigation, a tiny version of zfm
#               but with a different indexing mechanism
#       Author: rkumar http://github.com/rkumar/cetus/
#         Date: 2013-02-17 - 17:48
#      License: GPL
#  Last update: 2019-03-29 11:41
# --------------------------------------------------------------------------- #
#  cetus.rb  Copyright (C) 2012-2019 rahul kumar
# == CHANGELOG
# 2019-03-24 - adding colors per line, but columnate will have to change
#  since size calc will include color codes. Same for truncate
# 2019-02-20 - added smcup and rmcup so alt-screen is used. works a bit
# 2019-03-04 - change clear to go to 0,0 and clear down to reduce pollution
# 2019-03-04 - changed quit to q (earlier Q)
# 2019-03-04 - first dirs then files
# 2019-03-10 - changing selected_files to have fullpath
# 2019-03-22 - refactoring the code, esp run()
#  == TODO
#  a method is called from. a menu or direct from key. e.g help
#  To dirs add GEMHOME RUBYLIB PYTHONILB or PYTHONPATH,
#  Make rubygem aware : gemspec or Gemfile the expand lib and bin
#  fpath if existing

require 'readline'
require 'io/wait'
# http://www.ruby-doc.org/stdlib-1.9.3/libdoc/shellwords/rdoc/Shellwords.html
require 'shellwords'
# https://docs.ruby-lang.org/en/2.6.0/FileUtils.html
require 'fileutils'
require 'logger'
@log = Logger.new('log.txt')

## INSTALLATION
# copy into PATH
# alias c=~/bin/cetus.rb
# c

VERSION = '0.1.30.0'.freeze
CONFIG_FILE = '~/.config/cetus/conf.yml'.freeze

# $bindings = {}
$bindings = {
  '`' => 'main_menu',
  '=' => 'toggle_menu',
  'M-s' => 'selection_menu',
  'M-o' => 'sort_menu',
  'ENTER' => 'select_current',
  'C-p' => 'page_current',
  'C-e' => 'edit_current',
  'C-o' => 'edit_current',
  'C-s' => 'toggle_select',
  'C-r' => 'reduce',
  'C-g' => 'debug_vars',
  '@' => 'selection_mode_toggle',
  'M-a' => 'select_all',
  'M-A' => 'unselect_all',
  '!' => 'execute',
  ',' => 'goto_parent_dir',
  '~' => 'goto_home_dir',
  '-' => 'goto_previous_dir',
  '+' => 'goto_dir',          # 2019-03-07 - TODO: change binding
  '.' => 'pop_dir',
  ':' => 'subcommand',
  "'" => 'goto_bookmark',
  '/' => 'enter_regex',
  'M-p' => 'prev_page',
  'M-n' => 'next_page',
  'SPACE' => 'next_page:Page Down',
  'M-f' => 'select_from_visited_files',
  'M-d' => 'select_from_used_dirs',
  'M-b' => 'bookmark_menu',
  'M-m' => 'create_bookmark',
  'M-M' => 'view_bookmarks',
  'C-c' => 'escape',
  'ESCAPE' => 'escape',
  'TAB' => 'views',
  'C-i' => 'views',
  # '?' => 'dirtree',
  'D' => 'delete_file',
  'M' => 'file_actions most',
  'q' => 'quit_command', # was Q now q 2019-03-04 -
  # "RIGHT"   => "column_next",
  'RIGHT' => 'select_current', # changed 2018-03-12 - for faster navigation
  'LEFT' => 'goto_parent_dir', # changed on 2018-03-12 - earlier column_next 1
  ']' => 'column_next: goto next column',
  '[' => 'column_next 1: goto previous column',
  'C-x' => 'file_actions',
  'M--' => 'columns_incdec -1: reduce column width',
  'M-+' => 'columns_incdec 1: increase column width',
  'S' => 'command_file list y ls -lh',
  'L' => 'command_file Page n less',
  'C-d' => 'cursor_scroll_dn',
  'C-b' => 'cursor_scroll_up',
  'UP' => 'cursor_up',
  'DOWN' => 'cursor_dn',
  'C-SPACE' => 'visual_mode_toggle',

  '?' => 'print_help',
  'F1' => 'print_help',
  'F2' => 'child_dirs',
  'F3' => 'dirtree',
  'F4' => 'tree',
  'S-F1' => 'dirtree',
  'S-F2' => 'tree'

}

## clean this up a bit, copied from shell program and macro'd
$kh = {}
$kh["\eOP"] = 'F1'
$kh["\e[A"] = 'UP'
$kh["\e[5~"] = 'PGUP'
$kh[''] = 'ESCAPE'
KEY_PGDN = "\e[6~".freeze
KEY_PGUP = "\e[5~".freeze
## I needed to replace the O with a [ for this to work
#  in Vim Home comes as ^[OH whereas on the command line it is correct as ^[[H
KEY_HOME = '[H'.freeze
KEY_END = "\e[F".freeze
KEY_F1 = "\eOP".freeze
KEY_UP = "\e[A".freeze
KEY_DOWN = "\e[B".freeze

$kh[KEY_PGDN] = 'PgDn'
$kh[KEY_PGUP] = 'PgUp'
$kh[KEY_HOME] = 'Home'
$kh[KEY_END] = 'End'
$kh[KEY_F1] = 'F1'
$kh[KEY_UP] = 'UP'
$kh[KEY_DOWN] = 'DOWN'
KEY_LEFT = '[D'.freeze
KEY_RIGHT = '[C'.freeze
$kh["\eOQ"] = 'F2'
$kh["\eOR"] = 'F3'
$kh["\eOS"] = 'F4'
$kh[KEY_LEFT] = 'LEFT'
$kh[KEY_RIGHT] = 'RIGHT'
KEY_F5 = '[15~'.freeze
KEY_F6 = '[17~'.freeze
KEY_F7 = '[18~'.freeze
KEY_F8 = '[19~'.freeze
KEY_F9 = '[20~'.freeze
KEY_F10 = '[21~'.freeze
KEY_S_F1 = '[1;2P'.freeze
$kh[KEY_F5] = 'F5'
$kh[KEY_F6] = 'F6'
$kh[KEY_F7] = 'F7'
$kh[KEY_F8] = 'F8'
$kh[KEY_F9] = 'F9'
$kh[KEY_F10] = 'F10'
# testing out shift+Function. these are the codes my kb generates
$kh[KEY_S_F1] = 'S-F1'
$kh['[1;2Q'] = 'S-F2'

# copied from fff
def clear_screen
  # Only clear the scrolling window (dir item list).
  # '\e[%sH':    Move cursor to bottom of scroll area.
  # '\e[9999C':  Move cursor to right edge of the terminal.
  # '\e[1J':     Clear screen to top left corner (from cursor up).
  # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
  # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
  #              Also sets cursor to (0,0).
  # ENV["TMUX:+\e[2J]"],
  printf("\e[%sH\e[9999C\e[1J\e[1;%sr", \
         $glines - 0, # was 2
         $glines) # was grows
end

# copied from fff
# Call before shelling to editor pager and when exiting
def reset_terminal
  # Reset the terminal to a useable state (undo all changes).
  # '\e[?7h':  Re-enable line wrapping.
  # '\e[?25h': Unhide the cursor.
  # '\e[2J':   Clear the terminal.
  # '\e[;r':   Set the scroll region to its default value.
  #            Also sets cursor to (0,0).
  # '\e[?1049l: Restore main screen buffer.
  print "\e[?7h\e[?25h\e[2J\e[;r\e[?1049l"

  # Show user input.
  system 'stty echo'
end

# copied from fff
# call AFTER shelling to most or vim
def setup_terminal
  # Setup the terminal for the TUI.
  # '\e[?1049h': Use alternative screen buffer. smcup
  # '\e[?7l':    Disable line wrapping.
  # '\e[?25l':   Hide the cursor.
  # '\e[2J':     Clear the screen.
  # '\e[1;Nr':   Limit scrolling to scrolling area.
  #              Also sets cursor to (0,0).
  # printf("\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr", $glines)
  # 2019-03-29 - XXX temporarily not hiding cursor to see if we can place it.
  printf("\e[?1049h\e[?7l\e[?25h\e[2J\e[1;%sr", $glines)
  # earlier glines was grows

  # Hide echoing of user input
  system 'stty -echo'
end

# wrap readline so C-c can be ignored, but blank is taken as default
def readline prompt='>'
  # unhide cursor
  print "\e[?25h"
  begin
    target = Readline.readline(prompt, true)
  rescue Interrupt
    return nil
  ensure
    # hide cursor
    print "\e[?25l"
  end
  target.chomp
end

## get a character from user and return as a string
# Adapted from:
# http://stackoverflow.com/questions/174933/how-to-get-a-single-character-without-pressing-enter/8274275#8274275
# Need to take complex keys and match against a hash.
def get_char
  system('stty raw -echo 2>/dev/null') # turn raw input on
  c = nil
  # if $stdin.ready?
  c = $stdin.getc
  cn = c.ord
  return 'ENTER' if cn == 10 || cn == 13
  return 'BACKSPACE' if cn == 127
  return 'C-SPACE' if cn == 0
  return 'SPACE' if cn == 32
  # next does not seem to work, you need to bind C-i
  return 'TAB' if cn == 8

  if cn >= 0 && cn < 27
    x = cn + 96
    return "C-#{x.chr}"
  end
  if c == ''
    buff = c.chr
    loop do
      k = nil
      if $stdin.ready?
        k = $stdin.getc
        # puts "got #{k}"
        buff += k.chr
      else
        x = $kh[buff]
        return x if x

        # puts "returning with  #{buff}"
        if buff.size == 2
          ## possibly a meta/alt char
          k = buff[-1]
          return "M-#{k.chr}"
        end
        return buff
      end
    end
  end
  # end
  return c.chr if c
ensure
  system('stty -raw echo 2>/dev/null') # turn raw input on
end

## GLOBALS
$IDX = ('a'..'y').to_a
$IDX.delete 'q'
$IDX.concat ('za'..'zz').to_a
$IDX.concat ('Za'..'Zz').to_a
$IDX.concat ('ZA'..'ZZ').to_a

$selected_files = []
$bookmarks = {}
$mode = nil
$glines = `tput lines`.to_i
$gcols = `tput cols`.to_i
$grows = $glines - 3  # can be a func
# $pagesize = 60
$gviscols = 3
$pagesize = $grows * $gviscols # can be a func
$stact = 0 # used when panning a folder to next column
# $editor_mode = true
$editor_mode = false # changed 2018-03-12 - so we start in pager mode
$enhanced_mode = true
$visual_block_start = nil
$pager_command = {
  text: 'most',
  image: 'open',
  zip: 'tar ztvf %% | most',
  unknown: 'open'
}
$dir_position = {}

## ----------------- CONSTANTS ----------------- ##
GMARK = '*'.freeze
CURMARK = '>'.freeze
MSCROLL = 10
SPACE = ' '.freeze
CLEAR      = "\e[0m".freeze
BOLD       = "\e[1m".freeze
BOLD_OFF = "\e[22m".freeze
RED = "\e[31m".freeze
ON_RED = "\e[41m".freeze
GREEN      = "\e[32m".freeze
YELLOW     = "\e[33m".freeze
BLUE       = "\e[1;34m".freeze
MAGENTA    = "\e[35m".freeze
CYAN       = "\e[36m".freeze

ON_BLUE    = "\e[44m".freeze
REVERSE    = "\e[7m".freeze
UNDERLINE    = "\e[4m".freeze
CURSOR_COLOR = REVERSE

# NOTE: that osx uses LSCOLORS which only has colors for filetypes not
#  extensions and patterns which LS_COLORS has.
# LS_COLORS contains 2 character filetype colors. ex executable mi broken link
#   extension based colros starting with '*.'
#   file pattern starting with '*' and a character that is not .
#   File.ftype(path) returns
#   file, directory di, characterSpecial cd, blockSpecial bd, fifo pi, link ln, socket so, or unknown
# This hash contains color codes for extensions. It is updated from
# LS_COLORS.
$ls_color = {
  '.rb' => RED,
  '.tgz' => MAGENTA,
  '.zip' => MAGENTA,
  '.torrent' => GREEN,
  '.srt' => GREEN,
  '.sh' => CYAN
}
# This hash contains colors for file patterns, updated from LS_COLORS
$ls_pattern = {}
# This hash contains colors for file types, updated from LS_COLORS
$ls_ftype = {}
## --------------------------------------------- ##

$patt = nil
$ignorecase = true
$quitting = false
$modified = $writing = false
$visited_files = []
## dir stack for popping
$visited_dirs = []
## dirs where some work has been done, for saving and restoring
$used_dirs = []
# zsh o = order m = modified time
$default_sort_order = 'om'
$sorto = $default_sort_order
$viewctr = 0
$history = []
## sta is where view (viewport) begins, cursor is current row/file
$sta = $cursor = 0
$visual_mode = false
$status_color = 4 # status line, can be 2 3 4 5 6

# Menubar on top of screen
@help = "#{BOLD}?#{BOLD_OFF} Help   #{BOLD}`#{BOLD_OFF} Menu   #{BOLD}!#{BOLD_OFF} Execute   #{BOLD}=#{BOLD_OFF} Toggle   #{BOLD}C-x#{BOLD_OFF} File Actions  #{BOLD}q#{BOLD_OFF} Quit "

# ------------------- read_directory ------------------ #
def read_directory
  rescan_required false

  # http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html
  # zsh print -rl
  # -l Print the arguments separated by newlines instead of spaces.
  # -r Ignore the escape conventions of echo.
  # zshglob M = MARK_DIRS

  $filterstr ||= 'M'
  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}#{$filterstr})'`.split("\n")
  $files = sort_file_list $files
  enhance_file_list
  ## added by RK 2014-03-31 - 00:29 since too many duplicates
  $files = $files.uniq if $enhanced_mode
end
# ------------- end of read_directory --------------------------------#

# ------------------- create_viewport ------------------ #
def create_viewport
  $view = if $patt
            if $ignorecase
              $files.grep(/#{$patt}/i)
            else
              $files.grep(/#{$patt}/)
            end
          else
            $files
          end

  fl = $view.size
  $sta = 0 if $sta >= fl || $sta < 0
  $cursor = 0 if $cursor >= fl || $cursor < 0

  # NOTE if we make cursor zero, then it can be < sta so in the next line
  #  it will be made equal to sta which we may not want
  $cursor = $sta if $sta > $cursor

  # viewport are the files that are visible, subset of view
  $viewport = $view[$sta, $pagesize]
end
# ------------- end of create_viewport --------------------------------#

# ------------------- print_title ------------------ #
def print_title

  # print help line and version
  print "#{GREEN}#{@help}  #{BLUE}cetus #{VERSION}#{CLEAR}\n"

  # print 1 of n files, sort order, filter etc details
  $title ||= Dir.pwd.sub(ENV['HOME'], '~')
  fin = $sta + $viewport.size
  fl = $view.size
  t = "#{$title}  #{$sta + 1} to #{fin} of #{fl}  #{$sorto} F:#{$filterstr}"

  # don't exceed columns while printing
  t = t[t.size - $gcols..-1] if t.size >= $gcols

  print "#{BOLD}#{t}#{CLEAR}\n"
end
# ------------- end of print_title --------------------------------#

# TODO: clean this up and simplify it
def status_line
    # prompt
    v_mm = $mode ? "[#{$mode}] " : ''
    cf = current_file
    $message = "No file highlighted (#{cf})" if cf and !$highlighted_a_column
    $message = ' | No matches. Press ESCAPE' if $patt && !cf

    clear_status_line

    # Print the filename at the right side of the status_line
    # sometimes due to search, there is no file
    if cf
      if @debug_flag
        print_on_right "#{$sta},#{$cursor},#{$stact},#{$viewport.size},#{$grows} | #{cf}"
      else
        print_on_right "#{cf}"
      end
    end
    # move to beginning of line, reset text mode after printing
    print "\r#{v_mm}#{$patt}#{$message}\e[m"

end

# should we do a read of the dir
def rescan?
  $rescan_required
end

def rescan_required flag=true
  $rescan_required = flag
  redraw_required if flag
end

def redraw flag=false
  read_directory if flag

  draw_directory
end

def draw_directory
  # all this seems to be happening for each keystroke even if
  # not really required. FIXME maybe reduce and call when required


  # view consists of all files (filtered by pattern if necessary)
  # viewport is only that subset of view that is displayed on screen
  create_viewport
  clear_screen
  print_title

  # add hint and format the line
  buff = format_array $viewport

  # break viewport into as many columns as required
  # This is where directories get their blue color
  buff = columnate buff, $grows

  # starts printing array on line 3
  buff.each { |line| print line, "\n" }
  print

  status_line

  # place cursor correctly, we will use this to highlight current row
  place_cursor
end

# place cursor correctly, we will use this to highlight current row
def place_cursor
  if $cursor <= $grows
    system "tput cup #{$cursor + 2} 0"
    return
  end
  wid = get_width $viewport.size, $grows
  rows = $cursor % $grows
  cols = ($cursor / $grows) * wid
  system "tput cup #{rows + 2} #{cols}"
end

def redraw_required(flag=true) $redraw_required = flag; end

def resolve_key key
  if key.match?(/^[a-pr-zZ]$/)
    # hint mode
    select_hint $viewport, key
  elsif key == 'BACKSPACE'
    # do we really need this TODO
    $patt = $patt[0..-2] if $patt && !$patt.empty?
    $message = $patt = nil if $patt == ''
  else
    resolve_binding key
  end
end

def resolve_binding key
  # fetch binding for key
  x = $bindings[key]

  # remove comment string so only binding is left
  x, _ = x.split(':') if x

  # split into binding and args
  x = x.split if x
  if x
    binding = x.shift
    args = x
    send(binding, *args) if binding
  else
    perror "No binding for #{key}"
  end
end



## write current dir to a file so we can ccd to it when exiting
def write_curdir
  f = File.expand_path('~/.fff_d')
  s = Dir.pwd
  File.open(f, 'w') do |f2|
    f2.puts s
  end
  # puts "Written #{s} to #{f}"
end

## code related to long listing of files
GIGA_SIZE = 1_073_741_824.0
MEGA_SIZE = 1_048_576.0
KILO_SIZE = 1024.0

# Return the file size with a readable style.
# NOTE format is a kernel method.
def readable_file_size(size, precision)
  if size < KILO_SIZE then format('%d B', size)
  elsif size < MEGA_SIZE then format("%.#{precision}f K", (size / KILO_SIZE))
  elsif size < GIGA_SIZE then format("%.#{precision}f M", (size / MEGA_SIZE))
  else format("%.#{precision}f G", (size / GIGA_SIZE))
  end
end

## format date for file given stat
def date_format(t)
  t.strftime '%Y/%m/%d'
end

##
#
# print in columns
# ary - array of data (viewport, not view)
# siz  - how many lines should there be in one column
#
def columnate ary, siz
  buff = []
  return buff if ary.nil? || ary.empty?

  # 2019-03-19 - just to make sure highlighted column is visible - remove
  $highlighted_a_column = false

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  wid = get_width ary.size, siz

  # ix refers to the index in the complete file list, wherease we only show 60 at a time
  ix = 0
  loop do
    ## ctr refers to the index in the column
    #  siz is how many items in one column
    ctr = 0
    while ctr < siz

      f = ary[ix]
      # f is not just filename but marker and hint
      # Check last char to see if directory
      linecolor = nil
      linecolor = BLUE if f[-1] == '/'

      # check to see if we need to truncate
      # 2019-03-18 - truncate from middle of string.
      # 2019-03-24 - truncate and size to take care of color codes
      # fsz = f.size
      unformatted_len, _ = filename_len(f)
      if unformatted_len > wid
        # take the excess out from the center on both sides
        f = truncate_formatted_filename(f, unformatted_len, wid)

        if ix + $sta == $cursor
          f = "#{CURSOR_COLOR}#{f}#{CLEAR}"
          $highlighted_a_column = true
        elsif linecolor
          f = "#{linecolor}#{f}#{CLEAR}"
        end

      else

        ## we do the coloring before padding so the entire line does not get
        # padded, only file name
        if ix + $sta == $cursor
          f = "#{CURSOR_COLOR}#{f}#{CLEAR}"
          $highlighted_a_column = true
        elsif linecolor
          f = "#{linecolor}#{f}#{CLEAR}"
        end
        # f = f.ljust(wid)
        f << ' ' * (wid - unformatted_len)

      end

      # if already a value in that line, append to it
      if buff[ctr]
        buff[ctr] += f
      else
        buff[ctr] = f
      end

      ctr += 1
      ix += 1
      break if ix >= ary.size
    end
    break if ix >= ary.size
  end
  buff
end

# shorten the filename to wid
# unformatted_len is the length without ANSI formatting
def truncate_formatted_filename f, unformatted_len, wid
  excess = unformatted_len - wid
  center = unformatted_len / 2
  excess_half = excess / 2
  point = center + excess_half
  point1 = point - excess
  # the space comes after the ANSI formatting
  f = f[0..(point1 - 1)] + '$' + f[point + 2 .. -1] + ' '
  f
end

def get_width arysz, siz
  ars = [$pagesize, arysz].min
  d = 0
  return $gcols - d if ars <= siz

  tmp = (ars * 1.000 / siz).ceil
  wid = $gcols / tmp - d
  wid
end

# calculate length of filename without ANSI color codes
def filename_len name
  l = name.length
  return l if name[0] != "\e"

  # we have an escape code at the start of the name (and end, too)
  index = name.index('m')
  eindex = name.rindex("\e")
  reall = eindex - index - 1
  return reall, l
end

## formats the data with number, mark and details
def format_array(ary)
  # buff = Array.new
  buff = Array.new(ary.size)
  return buff if ary.nil? || ary.empty?

  # determine width based on number of files to show
  # if less than sz then 1 col and full width
  #
  # ix refers to the index in the complete file list, whereas we only
  # show 60 at a time
  ix = 0
  ctr = 0
  ary.each do |f|
    # raise "#{f} != #{ary[ix]}" if f != ary[ix]
    ## ctr refers to the index in the column
    ind = get_shortcut(ix)
    mark = SPACE
    mark = '+' if visited? f
    cur = SPACE
    cur = CURMARK if ix + $sta == $cursor
    # NOTE seems like f and ary[ix] are the same
    mark = GMARK if selected?(ary[ix])

    if $long_listing
      begin
        if File.exist? f
          stat = File.stat(f)
        else
          # remove last character and get stat
          last = f[-1]
          stat = File.stat(f.chop) if last == ' ' || last == '@' || last == '*'
        end
        # this is for saved directories etc which are shortened
        stat ||= File.stat(File.expand_path(f))
        f = format('%10s  %s  %s', readable_file_size(stat.size, 1),
                   date_format(stat.mtime), f)
      rescue StandardError => e
        f = format('%10s  %s  %s', '?', '??????????', f)
      end
    end

    # FIXME this will not work in long listing !!
    color = color_for f

    s = "#{ind}#{mark}#{cur}#{f}"
    if color
      s = "#{color}#{s}#{CLEAR}"
    end

    buff[ctr] = s

    ctr += 1
    ix += 1
  end
  buff
end

# determine color for a filename based on extension, then pattern, then filetype
def color_for fname
  extension = File.extname(fname)
  color = $ls_color[extension]
  return color if color

  # check file against patterns
  # NOTE: this could be slow
  if File.file?(fname)
    $ls_pattern.each_pair do |k, v|
      # if fname.match?(/k/)
      if fname =~ /#{k}/
        # @log.debug "#{fname} matched #{k}. color is #{v[1..-2]}"
        return v
      # else
        # @log.debug "#{fname} di not match #{k}. color is #{v[1..-2]}"
      end
    end
  end
  # check filetypes
  # @log.debug "File:#{fname}"
  if File.exist? fname
  # @log.debug "Filetype:#{File.ftype(fname)}"
    return $ls_ftype[File.ftype(fname)]
  else
    @log.warn "FILE WRONG: #{fname}"
  end
  nil
end

def parse_ls_colors

  colorvar = ENV['LS_COLORS']
  if colorvar.nil?
    $ls_colors_found = nil
    return
  end
  $ls_colors_found = true
  ls = colorvar.split(':')
  ls.each do |e|
    patt, colr = e.split '='
    colr = "\e[" + colr + 'm'
    if e.start_with? '*.'
      # extension, avoid '*' and use the rest as key
      $ls_color[patt[1..-1]] = colr
    elsif e[0] == '*'
      # file pattern, this would be a glob pattern not regex
      # only for files not directories
      patt = patt.gsub('.', '\.')
      patt = patt.sub('+', '\\\+') # if i put a plus it does not go at all
      patt = patt.gsub('-', '\-')
      patt = patt.gsub('?', '.')
      patt = patt.gsub('*', '.*')
      patt = "^#{patt}" if patt[0] != '.'
      patt = "#{patt}$" if patt[-1] != '*'
      $ls_pattern[patt] = colr
      @log.debug "Writing pattern (#{patt})."
    elsif patt.length == 2
      # file type, needs to be mapped to what ruby will return
#   file, directory di, characterSpecial cd, blockSpecial bd, fifo pi, link ln, socket so, or unknown
      case patt
      when 'di'
        $ls_ftype['directory'] = colr
      when 'cd'
        $ls_ftype['characterSpecial'] = colr
      when 'bd'
        $ls_ftype['blockSpecial'] = colr
      when 'pi'
        $ls_ftype['fifo'] = colr
      when 'ln'
        $ls_ftype['link'] = colr
      when 'so'
        $ls_ftype['socket'] = colr
      else
        $ls_ftype[patt] = colr
      end
    end
  end
end

## select file based on key pressed
def select_hint view, key
  # a to y is direct
  # if x or z take a key IF there are those many
  #
  ix = get_index(key, view.size)
  return unless ix

  f = view[ix]
  return unless f

  $cursor = $sta + ix

  if $mode == 'SEL'
    toggle_select f
  elsif $mode == 'COM'
    run_command f
  else
    open_file f
  end
end

## toggle selection state of file
def toggle_select(f=current_file)
  # dir = Dir.pwd
  # file = File.join(dir, f)
  if selected? f
    remove_from_selection f
  else
    add_to_selection f
  end
  # XXX is it possible to just redraw this line
  redraw_required
end

## open file or directory
def open_file(f)
  return unless f

  f = File.expand_path(f) if f[0] == '~'
  unless File.exist? f
    # this happens if we use (T) in place of (M)
    # it places a space after normal files and @ and * which borks commands
    last = f[-1]
    f = f.chop if last == ' ' || last == '@' || last == '*'
  end
  nextpos = nil

  # could be a bookmark with position attached to it
  f, nextpos = f.split(':') if f.index(':')
  if File.directory? f
    save_dir_pos
    change_dir f #, nextpos
  elsif File.readable? f
    # TODO: looks complex pls simplify !! XXX
    $default_command ||= '$PAGER'
    if !$editor_mode
      ft = filetype f
      if ft
        comm = $pager_command[ft]
      else
        comm = $pager_command[File.extname(f)]
        comm ||= $pager_command['unknown']
      end
    else
      comm = $default_command
    end
    comm ||= $default_command
    comm = if comm.index('%%')
             comm.gsub('%%', Shellwords.escape(f))
           else
             comm + " #{Shellwords.escape(f)}"
           end
    clear_screen
    reset_terminal
    system(comm.to_s)
    setup_terminal
    f = Dir.pwd + '/' + f if f[0] != '/'
    $visited_files.insert(0, f)
    push_used_dirs Dir.pwd
  else
    perror "open_file: (#{f}) not found"
    # could check home dir or CDPATH env variable DO
  end
  redraw_required
end

# regardless of mode, view the current file using pager
def page_current
  command = ENV['MANPAGER'] || ENV['PAGER'] || 'less'
  run_on_current command
end

# regardless of mode, edit the current file using editor
def edit_current
  command = ENV['EDITOR'] || ENV['VISUAL'] || 'vim'
  run_on_current command
  $visited_files.insert(0, current_file)
end

# run given command on current file
def run_on_current(command)
  f = $view[$cursor]
  return unless f
  f = File.expand_path(f)
  return unless File.readable?(f)

  clear_screen
  reset_terminal
  comm = "#{command} #{f}"
  system(comm.to_s)
  push_used_dirs
  setup_terminal
end

## run command on given file/s
#   Accepts command from user
#   After putting readline in place of gets, pressing a C-c has a delayed effect.
#   It goes into exception block after executing other commands and still
#   does not do the return !
def run_command(f)
  files = nil
  case f
  when Array
    # escape the contents and create a string
    files = Shellwords.join(f)
  when String
    files = Shellwords.escape(f)
  end
  print "Run a command on #{files}: "
  begin
    # Readline::HISTORY.push(*values)
    command = readline
    # command = gets().chomp
    return if command.empty?

    print 'Second part of command: '
    # command2 = gets().chomp
    command2 = readline
    puts "#{command} #{files} #{command2}"
    system "#{command} #{files} #{command2}"
    setup_terminal
  rescue StandardError => ex
    perror "Canceled command, (#{ex}) press a key"
    return
  end

  refresh
  puts 'Press a key ...'
  push_used_dirs Dir.pwd
  get_char
end

## cd to a dir.
def change_dir f
  unless File.directory? f
    perror "#{f} is not a directory, or does not exist."
    return
  end

  # before leaving a dir we save it in the list, as well as the cursor
  # position, so we can restore that position when we return
  $visited_dirs.insert(0, Dir.pwd)
  save_dir_pos

  f = File.expand_path(f)
  Dir.chdir f
  read_directory
  post_cd

  redraw_required
end

def goto_previous_dir
  prev_dir = $visited_dirs.first
  return unless prev_dir
  change_dir prev_dir
end

def index_of dir
  $files.index(dir)
end

## clear sort order and refresh listing, used typically if you are in some view
#  such as visited dirs or files
def escape
  $sorto = nil
  $sorto = $default_sort_order
  $viewctr = 0
  $title = nil
  $filterstr = 'M'
  $message = nil
  visual_block_clear
  refresh
end

## refresh listing after some change like option change, or toggle
def refresh
  $patt = nil
  $title = nil
  rescan_required
end

# put directories first, then files
def sort_file_list(_files)
  _dirs = $files.select { |f| File.directory?(f) }
  _files = $files.select { |f| File.file?(f) }
  _dirs + _files
end

## unselect all files
def unselect_all
  $selected_files = []
  $visual_mode = nil
end

## select all files
def select_all
  dir = Dir.pwd
  $selected_files = $view.map { |file| File.join(dir, file) }
end

## accept dir to goto and change to that ( can be a file too)
def goto_dir
  # print "\e[?25h"
  print_last_line 'Enter path: '
  begin
    # path = gets.chomp
    path = readline
    if path.nil? || path == ''
      clear_status_line
      return
    end
    # rescue => ex
  rescue StandardError => ex
    # Nope, already caught interrupt and sent back nil
    perror 'Cancelled cd, press a key'
    return
  ensure
    # print "\e[?25l"
  end
  f = File.expand_path(path)
  unless File.directory? f
    ## check for env variable
    tmp = ENV[path]
    if tmp.nil? || !File.directory?(tmp)
      ## check for dir in home
      tmp = File.expand_path("~/#{path}")
      f = tmp if File.directory? tmp
    else
      f = tmp
    end
  end

  open_file f
end

## toggle mode to selection or not
#  In selection, pressed hotkey selects a file without opening, one can keep selecting
#  (or deselecting).
#
def selection_mode_toggle
  if $mode == 'SEL'
    unselect_all
    $mode = nil
  else
    # $selection_mode = !$selection_mode
    $mode = 'SEL'
  end
end

# go to parent dir, and maintain cursor on the dir we came out of
def goto_parent_dir
  # When changing to parent, we need to keep cursor on
  #  parent dir, not first
  curr = File.basename(Dir.pwd)

  change_dir '..'

  # get index of child dir in this dir, and set cursor to it.
  index = $files.index(curr + '/')
  pause "WARNING: Could not find #{curr} in this directory." unless index
  $cursor = index if index
end

def goto_home_dir
  change_dir '~'
end

## This actually filters, in zfm it goes to that entry since we have a cursor there
#
def goto_entry_starting_with(fc = nil)
  unless fc
    print 'Entries starting with: '
    fc = get_char
  end
  return if fc.size != 1

  ## this is wrong and duplicates the functionality of /
  #  It shoud go to cursor of item starting with fc
  $patt = "^#{fc}"
end

# Goes to directory bookmarked with number or upper case char.
# If lower case character given, then go to first file starting with char.
def goto_bookmark(key = nil)
  unless key
    print 'Enter bookmark char: '
    key = get_char
  end
  if key =~ /^[0-9A-Z]$/
    d = $bookmarks[key]
    # this is if we use zfm's bookmarks which have a position
    # this way we leave the position as is, so it gets written back
    nextpos = nil
    if d
      if d.index(':')
        ix = d.index(':')
        nextpos = d[ix + 1..-1]
        d = d[0, ix]
      end
      change_dir d #, nextpos
    else
      perror "#{key} not a bookmark"
    end
  else
    # goto_entry_starting_with key
    file_starting_with key
  end
end

## take regex from user, to run on files on screen, user can filter file names
def enter_regex
  # print 'Enter (regex) pattern: '
  # move to beginning of line, and clear till EOL
  print "\r\e[K"
  $patt = readline '/'
end

# page/scroll down.
def next_page
  $sta += $pagesize
  $cursor += $pagesize
  $sta = $cursor if $sta > $cursor
  $stact = 0
  redraw_required
end

def prev_page
  $sta -= $pagesize
  $cursor -= $pagesize
  redraw_required
end

def print_help
  page_with_tempfile do |file|
    file.puts '    HELP'

    file.puts
    file.puts 'To open a file or dir press 1-9 a-z A-Z (on left of file)'
    file.puts 'Ctrl-s to select file under cursor'
    file.puts 'Selection Mode: Each selection adds to selection list (toggles)'
    file.puts '   Execute commands on selected files. e.g D C-x   '
    file.puts '   Upon exiting mode, selection is cleared'
    file.puts 'Use left and right arrows to move through directories'
    file.puts
    ary = []
    # 2019-03-19 -  if : then show text after colon
    $bindings.each_pair { |k, v|
      vv = v.tr('_', ' ')
      vv = vv.split(':')[1].strip if vv.include?(':')
      ary.push "#{k.ljust(7)}  =>  #{vv}"
    }
    # FIXME this works but not properly when long_listing is true.
    # We should avoid using columnate as there are several file related things.
    ary = columnate ary, (ary.size/2)+1
    ary.each { |line| file.puts line }
  end
end

def page_stat_for_file
  stat = %x[ stat #{current_file} ]
  return unless stat

  page_with_tempfile do |file|
    file.puts stat
  end

end

def page_with_tempfile
  require 'tempfile'
  file = Tempfile.new('cetus')
  begin
    yield file
    file.flush
    system "$PAGER #{file.path}"
    setup_terminal
  rescue StandardError
    file.close
    file.unlink
  end
end

def debug_vars
  @debug_flag = true
  page_with_tempfile do |file|
    file.puts 'DEBUG VARIABLES ARE:'
    file.puts
    file.puts "sta    #{$sta}"
    file.puts "cursor #{$cursor}"
    file.puts "stact  #{$stact}"
    file.puts "viewport.size  #{$viewport.size}"
    file.puts "pagesize       #{$pagesize}"
    file.puts "view.size      #{$view.size}"
    file.puts "grows          #{$grows}"
    file.puts "file   #{current_file}"
  end
  redraw_required
end

def view_bookmarks
  puts
  puts 'Bookmarks: '
  $bookmarks.each_pair { |k, v| puts "#{k.ljust(7)}  =>  #{v}" }
  puts
  print 'Enter bookmark to goto: '
  key = get_char
  goto_bookmark(key) if key =~ /^[0-9A-Z]$/
end

# MENU MAIN
def main_menu
  h = {
    :a => :ag,
    '/' => :ffind,
    :l => :locate,
    :V => :viminfo,
    :v => :vidir,
    :z => :z_interface,
    :d => :child_dirs,
    :r => :recent_files,
    '1' => :select_from_visited_files,
    '2' => :select_from_used_dirs,
    :t => :dirtree,
    '4' => :tree,
    :o => :sort_menu,
    :F => :filter_menu,
    :c => :command_menu,
    :b => :bookmark_menu,
    :s => :selection_menu,
    :B => :bindkey_ext_command,
    :M => :create_a_dir,
    '%' => :create_a_file,
    'S' => :scripts,
    :x => :extras
  }
  menu 'Main Menu', h
end

def selection_menu
  h = {
    :a => :select_all,
    :u => :unselect_all,
    :s => :toggle_select,
    '@' => 'selection_mode_toggle',
    'x' => 'visual_mode_toggle',
    :v => :view_selected_files
  }
  menu 'Selection Menu', h
end

def bookmark_menu
  h = {
    v: :view_bookmarks,
    c: :create_bookmark,
    g: :goto_bookmark
  }
  menu 'Bookmark Menu', h
end

# Create a menu using title, and hash of key and binding
def menu title, h
  return unless h

  pbold title.to_s
  # h.each_pair { |k, v| puts " #{k}: #{v}" }
  # 2019-03-09 - trying out using `column` to print in cols
  ary = []
  h.each_pair { |k, v| ary << " #{k}: #{v}" }
  x = ary.join("\n")
  puts %x{echo "#{x}" | column}

  key = get_char
  binding = h[key]
  binding ||= h[key.to_sym]
  # TODO: 2019-03-21 - menu's do not have comments, they are symbols
  # binding, _ = binding.split(':')
  if binding
    send(binding) if respond_to?(binding, true)
  end
  redraw_required
  [key, binding]
end

def toggle_menu
  h = { :h => :toggle_hidden, :c => :toggle_case, :l => :toggle_long_list, '1' => :toggle_columns,
        :p => :toggle_pager_mode, :e => :toggle_enhanced_list }
  _, menu_text = menu 'Toggle Menu', h
  return unless menu_text

  case menu_text
  when :toggle_hidden
    # zsh D - dot files should show
    $hidden = $hidden ? nil : 'D'
    # pause "Show hidden files is now #{!$hidden.nil?}. Press a key."
    message "Show hidden is now #{!$hidden.nil?}"
    rescan_required
  when :toggle_case
    # $ignorecase = $ignorecase ? "" : "i"
    $ignorecase = !$ignorecase
    # pause "Ignore Case is now #{$ignorecase}. Press a key."
    message "Ignore Case is now #{$ignorecase}"
    rescan_required
  when :toggle_columns
    if $gviscols == 1
      $gviscols = 3
    else
      $gviscols = 1
    end
    # $long_listing = false if $gviscols > 1
    x = $grows * $gviscols
    $pagesize = $pagesize == x ? $grows : x
    message "Visible columns now set to #{$gviscols}"
    rescan_required
  when :toggle_pager_mode
    $editor_mode = !$editor_mode
    $default_command = if $editor_mode
                         ENV['EDITOR'] # earlier nil # 2019-03-10 -
                         # it was nil so we could set a default command
                       else
                         ENV['MANPAGER'] || ENV['PAGER']
                       end
    message "Default command is #{$default_command}"
  when :toggle_enhanced_list
    $enhanced_mode = !$enhanced_mode
    message "Enhanced mode is #{$long_listing}"
    rescan_required

  when :toggle_long_list
    $long_listing = !$long_listing
    if $long_listing
      $saved_gviscols = $gviscols
      $gviscols = 1
      $pagesize = $grows
    else
      $gviscols = $saved_gviscols || 3
      x = $grows * $gviscols
      $pagesize = $pagesize == x ? $grows : x
    end
    if $stact > 0
      $sta = $stact
      $stact = 0 # in case user was panned 2019-03-20 -
    end
    message "Long listing is #{$long_listing}, vis cols is #{$gviscols}"
    rescan_required
  end
end

def sort_menu
  # zsh o = order, O = reverse order
  lo = nil
  h = { m: :modified, a: :accessed, M: :oldest,
        l: :largest, s: :smallest, n: :name, r: :rev_name, d: :dirs, c: :inode,
       z: :clear}
  _, menu_text = menu 'Sort Menu', h
  case menu_text
  when :modified
    lo = 'om'
  when :accessed
    lo = 'oa'
  when :inode
    lo = 'oc'
  when :oldest
    lo = 'Om'
  when :largest
    lo = 'OL'
  when :smallest
    lo = 'oL'
  when :name
    lo = 'on'
  when :rev_name
    lo = 'On'
  when :dirs
    lo = '/'
  when :clear
    lo = ''
  end
  ## This needs to persist and be a part of all listings, put in change_dir.
  $sorto = lo
  message "Sorted on #{menu_text}"
  rescan_required
end

# thse need to be placed in correct position, some do nothing
#  and some like ffind have no menu item
def command_menu
  #  since these involve full paths, we need more space, like only one column
  ## in these cases, getting back to the earlier dir, back to earlier listing
  # since we've basically overlaid the old listing
  # should be able to sort THIS listing and not rerun command. But for that I'd need to use
  # xargs ls -t etc rather than the zsh sort order. But we can run a filter using |.
  #
  h = { t: :today, D: :default_command, R: :remove_from_list,
        v: :view_selected_files }
  h[:e] = if $editor_mode
            :pager_mode
          else
            :editor_mode
          end
  _, menu_text = menu 'Command Menu', h
  case menu_text
  when :pager_mode
    $editor_mode = false
    $default_command = ENV['MANPAGER'] || ENV['PAGER']
  when :editor_mode
    $editor_mode = true
    $default_command = nil
  when :ffind
    ffind
  when :locate
    locate
  when :today
    # zshglob: M = MARK_DIRS with slash
    # zshglob: 'm0' 'm' = modified time, '0' = 0 days ago
    $files = `zsh -c 'print -rl -- *(#{$hidden}Mm0)'`.split("\n")
    $title = "Today's files"
  when :default_command
    puts ' This no longer works'
    puts 'Selecting a file usually invokes $EDITOR'
    puts 'What command do you want to use repeatedly on selected files: '
    $default_command = gets.chomp
    if $default_command != ''
      print 'Second part of command (maybe blank): '
      $default_command2 = gets.chomp
    else
      print 'Cleared default command, will default to $EDITOR'
      $default_command2 = nil
      $default_command = nil
    end
  end
  # redraw
end

# This is quite badly placed and named. Maybe these should go elsewhere
def extras
  h = { '1' => :one_column, '2' => :multi_column, :c => :columns, :r => :config_read, :w => :config_write }
  key, menu_text = menu 'Extras Menu', h
  case menu_text
  when :one_column
    $pagesize = $grows
  when :multi_column
    # $pagesize = 60
    $pagesize = $grows * $gviscols
  when :columns
    print "How many columns to show: 1-6 [current #{$gviscols}]? "
    key = get_char
    key = key.to_i
    if key > 0 && key < 7
      $gviscols = key.to_i
      $pagesize = $grows * $gviscols
    end
  end
end

def filter_menu
  h = { :d => :dirs, :f => :files, :e => :emptydirs, '0' => :emptyfiles,
  :r => :reduce_list, :x => :extension}
  _, menu_text = menu 'Filter Menu', h
  files = nil
  case menu_text
  when :dirs
    $filterstr = '/M'
    # zsh /M MARK_DIRS appends trailing '/' to directories
    files = `zsh -c 'print -rl -- *(#{$sorto}/M)'`.split("\n")
    $title = 'Filter: directories only'
  when :files
    $filterstr = '.'
    # zsh '.' for files, '/' for dirs
    files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}.)'`.split("\n")
    $title = 'Filter: files only'
  when :emptydirs
    $filterstr = '/D^F'
    # zsh F = full dirs, ^F empty dirs
    files = `zsh -c 'print -rl -- *(#{$sorto}/D^F)'`.split("\n")
    $title = 'Filter: empty directories'
  when :emptyfiles
    $filterstr = '.L0'
    # zsh .L size in bytes
    files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}.L0)'`.split("\n")
    $title = 'Filter: empty files'
  when :reduce_list
    files = reduce
  when :extension
    files = filter_for_current_extension
  end
  if files
    $files = files
    $stact = 0
    $message = "Filtered on #{menu_text}"
    # redraw
  end
end

def reduce pattern=nil
  unless pattern
    print 'Enter a pattern to reduce current list: '
    pattern = gets.chomp
  end
  $title = "Filter: pattern #{pattern}"
  $files = $files.select {|f| f.match(pattern)}
end

def filter_for_current_extension
  extn = File.extname(current_file)
  return unless extn
  reduce extn
end

def select_from_used_dirs
  $title = 'Used Directories'
  home = File.expand_path '~'
  $files = $used_dirs.uniq.map { |path| path.sub("#{home}", '~') }
  # redraw
end

def select_from_visited_files
  # not yet a unique list, needs to be unique and have latest pushed to top
  $title = 'Visited Files'
  home = File.expand_path '~'
  $files = $visited_files.uniq.map { |path| path.sub("#{home}", '~') }
  # redraw
end

# maybe unused ??? XXX
def select_bookmarks
  $title = 'Bookmarks'
  $files = $bookmarks.values
end

## part copied and changed from change_dir since we don't dir going back on top
#  or we'll be stuck in a cycle
def pop_dir
  # the first time we pop, we need to put the current on stack
  $visited_dirs.push Dir.pwd unless $visited_dirs.index(Dir.pwd)
  ## XXX make sure thre is something to pop
  d = $visited_dirs.delete_at 0
  ## XXX make sure the dir exists, cuold have been deleted. can be an error or crash otherwise
  $visited_dirs.push d
  Dir.chdir d
  post_cd
  rescan_required
end

# after changing directory
def post_cd
  $title = $patt = $message = nil
  $sta = $cursor = $stact = 0
  $visual_block_start = nil
  $current_dir = Dir.pwd
  screen_settings

  # goto last position cursor was in this dir
  revert_dir_pos
end

## read dirs and files and bookmarks from file
def config_read
  f = File.expand_path(CONFIG_FILE)
  return unless File.readable? f

  hash = loadYML(f)
  $used_dirs = hash['DIRS']
  $visited_files = hash['FILES']
  $bookmarks = hash['BOOKMARKS']
  $used_dirs.concat get_env_paths
end

def get_env_paths
  files = []
  %w[GEM_HOME PYTHONHOME].each do |p|
    d = ENV[p]
    files.push d if d
  end
  %w[RUBYLIB RUBYPATH GEM_PATH PYTHONPATH].each do |p|
    d = ENV[p]
    files.concat d.split(':') if d
  end
  files
end

## save dirs and files and bookmarks to a file
# - moved to yml 2019-03-09
def config_write
  # Putting it in a format that zfm can also read and write
  f1 = File.expand_path(CONFIG_FILE)
  hash = {}
  hash['DIRS'] = $used_dirs.select {|dir| File.exist? dir}
  hash['FILES'] = $visited_files.select {|file| File.exist? file}
  # NOTE bookmarks is a hash and contains FILE:cursor_pos
  hash['BOOKMARKS'] = $bookmarks #.select {|file| File.exist? file}
  writeYML hash, f1
  $writing = $modified = false
  message "Saved #{f1}"
end

# {{{ YML
require 'yaml'
def loadYML( filename)
  hash = YAML::load( File.open( filename ) )
  if $opt_debug
    $stderr.puts hash.keys.size
  end
  return hash
end
def writeYML obj, filename
  File.open(filename, 'w') {|f| f.write obj.to_yaml }
  if $opt_debug
    $stderr.puts "Written to file #{filename}"
  end
end
# }}}

## accept a character to save this dir as a bookmark
def create_bookmark

  print 'Enter A to Z or 0-9 to create a bookmark: '
  print "\e[?25h" # unhide cursor
  key = get_char
  print "\e[?25l" # hide cursor
  if key =~ /^[0-9A-Z]$/
    # $bookmarks[key] = "#{Dir.pwd}:#{$cursor}"
    $bookmarks[key] = Dir.pwd
    $modified = true
    message "Created bookmark #{key}"
  else
    perror 'Bookmark must be upper-case character or number.'
  end
  # redraw
end

# allow user to exit using :q :wq :x
# Was this supposed to be augmented, or just remain limited like this
# We should be able to do everything in the menus from here. TODO
def subcommand
  print 'Enter command: q x wq p w e r h '
  begin
    command = readline
    return if command == ''
  rescue StandardError
    return
  end
  if command == 'q'
    # FIXME: 2019-03-22 - should this not call quit_command ?
    if $modified
      print 'Do you want to save bookmarks? (y/n): '
      key = get_char
      if key == 'y'
        $writing = true
        $quitting = true
      elsif key == 'n'
        $quitting = true
        print 'Quitting without saving bookmarks'
      else
        perror 'No action taken.'
      end
    else
      $quitting = true
    end
  elsif command == 'wq'
    $quitting = true
    $writing = true
  elsif command == 'w'
    config_write
  elsif command == 'x'
    $quitting = true
    $writing = true if $modified
  elsif command == 'e'
    edit_current
  elsif command == 'h' or command == 'help' or command == '?'
    print_help
  elsif command == 'p'
    system 'echo $PWD | pbcopy'
    puts 'Stored PWD in clipboard (using pbcopy)'
  else
    perror "Don't know about command #{command}. Try :h or :help"
  end
  # redraw
end

def quit_command
  if $modified
    puts 'Press w to save bookmarks before quitting ' if $modified
    print 'Press another q to quit '
    key = get_char
  else
    $quitting = true
  end
  $quitting = true if key == 'q'
  $quitting = $writing = true if key == 'w'
end

def views
  views = %w[/ om oa Om OL oL On on]
  viewlabels = %w[Dirs Newest Accessed Oldest Largest Smallest Reverse Name]
  $sorto = views[$viewctr]
  $title = viewlabels[$viewctr]
  $viewctr += 1
  $viewctr = 0 if $viewctr > views.size

  $files = `zsh -c 'print -rl -- *(#{$sorto}#{$hidden}M)'`.split("\n")
  # redraw
end

def child_dirs
  $title = 'Directories in current directory'
  # M is MARK_DIRS option for putting trailing slash after dir
  $files = `zsh -c 'print -rl -- *(/#{$sorto}#{$hidden}M)'`.split("\n")
  message "#{$files.size} files."
  # redraw
end

def dirtree
  $title = 'Child directories recursive'
  # zsh **/ is recursive
  $files = `zsh -c 'print -rl -- **/*(/#{$sorto}#{$hidden}M)'`.split("\n")
  message "#{$files.size} files."
  # redraw
end

#
# Get a full recursive listing of what's in this dir - useful for small projects with more
# structure than files.
def tree
  # Caution: use only for small projects, don't use in root.
  $title = 'Full Tree'
  $files = `zsh -c 'print -rl -- **/*(#{$sorto}#{$hidden}M)'`.split("\n")
  message "#{$files.size} files."
  # redraw
end

# lists recent files in current dir
# In some cases it shows mostly .git files, we need to prune those
def recent_files
  # print -rl -- **/*(Dom[1,10])
  $title = 'Recent files'
  # zsh D DOT_GLOB, show dot files
  # zsh om order on modification time
  $files = `zsh -c 'print -rl -- **/*(Dom[1,15])'`.split("\n").reject {|f| f[0] == '.'}
  # redraw
end

def select_current
  ## vp is local there, so i can do $vp[0]
  # open_file $view[$sta] if $view[$sta]
  open_file $view[$cursor] if $view[$cursor]
end

## create a list of dirs in which some action has happened, for saving
def push_used_dirs(d = Dir.pwd)
  # $used_dirs.index(d) || $used_dirs.push(d)
  return if $used_dirs[0] == d
  $used_dirs.delete(d) if $used_dirs.index(d)
  $used_dirs.insert(0, d)
end

def pbold text
  puts "#{BOLD}#{text}#{BOLD_OFF}"
end

# This is supposed to print on the status line
# but prints on next line.FIXME 2019-03-24 - 00:08
def perror text
  clear_status_line
  last_line
  print "#{RED}#{text}. Press a key.#{CLEAR}"
  get_char
end

def pause text=' Press a key.'
  print text
  get_char
end

## return shortcut for an index (offset in file array)
# use 2 more arrays to make this faster
#  if z or Z take another key if there are those many in view
#  Also, display ROWS * COLS so now we are not limited to 60.
def get_shortcut(ix)
  return '<' if ix < $stact

  ix -= $stact
  i = $IDX[ix]
  return i if i

  '->'
end

## returns the integer offset in view (file array based on a-y za-zz and Za - Zz
# Called when user types a key
#  should we even ask for a second key if there are not enough rows
#  What if we want to also trap z with numbers for other purposes
def get_index(key, vsz = 999)
  i = $IDX.index(key)
  return i + $stact if i

  # sz = $IDX.size
  zch = nil
  if vsz > 25
    if key == 'z' || key == 'Z'
      print key
      zch = get_char
      print zch
      i = $IDX.index("#{key}#{zch}")
      return i + $stact if i
    end
  end
  nil
end

def delete_file
  file_actions :delete
end

## generic external command program
#  prompt is the user friendly text of command such as list for ls, or extract for dtrx, page for less
#  pauseyn is whether to pause after command as in file or ls
#
def command_file(prompt, *command)
  pauseyn = command.shift
  command = command.join ' '
  print "[#{prompt}] Choose a file [#{$view[$cursor]}]: "
  file = ask_hint $view[$cursor]
  # print "#{prompt} :: Enter file shortcut: "
  # file = ask_hint
  perror 'Command Cancelled' unless file
  return unless file

  file = File.expand_path(file)
  if File.exist? file
    file = Shellwords.escape(file)
    pbold "#{command} #{file} (#{pauseyn})"
    system "#{command} #{file}"
    setup_terminal
    pause if pauseyn == 'y'
    refresh
  else
    perror "File #{file} not found"
  end
end

## prompt user for file shortcut and return file or nil
#
def ask_hint(deflt = nil)
  f = nil
  key = get_char
  return deflt if key == 'ENTER'

  ix = get_index(key, $viewport.size)
  f = $viewport[ix] if ix
  f
end

## check screen size and accordingly adjust some variables
#
def screen_settings
  $glines = `tput lines`.to_i
  $gcols = `tput cols`.to_i
  $grows = $glines - 3
  # $pagesize = 60
  # $gviscols = 3
  $pagesize = $grows * $gviscols
end

## Tabs to next column in multi-column displays.
#  Moves column offset so we can reach unindexed columns or entries,
#  or those with double letters
# 0 forward and any other back/prev
# direction is 0 (forward) or '1' (backward)
def column_next direction=0
  # right movement or panning cycles back to first column
  # leftward movement stops at first column.
  if direction == 0
    $stact += $grows
    $stact = 0 if $stact >= $viewport.size
    $cursor += $grows
    # 2019-03-18 - zero loses offset. we need to maintain it
    # $cursor = 0 if $cursor >= $viewport.size
    if $cursor - $sta >= $viewport.size
      $cursor -= $grows while $cursor > $sta
      $stact -= $grows while $stact > 0
      $cursor += $grows if $cursor < $sta
      $stact  += $grows if $stact < 0
    end
  else
    $stact -= $grows
    $cursor -= $grows
    $stact = 0 if $stact < 0
    # setting cursor as zero loses the position or offset
    # We are trying to maintain offset
    $cursor += $grows if $cursor < 0
  end
  # redraw
end

# currently i am only passing the action in from the list there as a key
# I should be able to pass in new actions that are external commands
# 2019-03-08 - TODO when a file name changes or moves it must be removed
#  from selection
def file_actions(action = nil)
  # only add dtrx for gz
  h = { d: :delete, m: :move, r: :rename, v: ENV['EDITOR'] || :vim,
        c: :copy, C: :chdir, W: :remspace, e: :execute, s: :page_stat_for_file,
        l: :less, p: :most, f: :file, o: :open, x: :dtrx, z: :zip }
  # acttext = h[action.to_sym] || action
  acttext = action || ''
  file = nil

  sct = $selected_files.size
  if sct > 0
    text = "#{sct} files"
    file = $selected_files
  else
    # 2019-03-07 - trying out direct deletes
    # why were we aksing to select a file when user is on a file
    # print "[#{acttext}] Choose a file [#{$view[$cursor]}]: "
    # file = ask_hint $view[$cursor]
    file = $view[$cursor]
    unless file
      file = ask_hint $view[$cursor]
    end
    return unless file

    text = file
  end
  # 2019-03-07 - NOTE at this point file can be one or more files.
  # 2019-03-07 - text can be a file or count of files, so unreliable !!! FIXME

  case file
  when Array
    # escape the contents and create a string
    files = Shellwords.join(file)
  when String
    files = Shellwords.escape(file)
  end

  key = nil
  if action
    menu_text = action
  else
    key, menu_text = menu "File Menu for #{text}", h
    menu_text = :quit if key == 'q'
  end
  return unless menu_text # pressed some wrong key

  case menu_text.to_sym

  when :quit

  when :delete
    delcommand = 'rmtrash'
    print "#{delcommand} #{text} ?[yn?]: "
    key = get_char
    view_selected_files if key == '?'
    return if key != 'y'

    system "#{delcommand} #{files}"
    refresh

  when :move
    # 2019-03-07 - NOTE this will only work with single file selection
    print "move #{text} to : "
    # target = gets().chomp
    # target = Readline.readline('>', true)
    target = readline
    return unless target

    target = '.' if target == ''
    # 2019-03-07 - NOTE cannot use text if multiple files
    # text = File.expand_path(text)
    target = File.expand_path(target)
    return if target == ''

    if File.directory? target
      begin
        FileUtils.mv file, target
        message "Moved #{text} to #{target}"
      rescue StandardError => exc
        perror exc.to_s
      end
      # 2019-03-08 - TODO if success remove from selection
      refresh
    else
      perror 'Target not a dir'
    end

  when :copy
    # Target must be directory
    print "copy #{text} to : "
    target = readline
    return unless target # C-c

    target = '.' if target == ''
    target = File.expand_path(target)
    return if target == ''

    if File.directory? target
      begin
        FileUtils.cp file, target
        message "Copied #{text} to #{target}"
      rescue StandardError => exc
        perror exc.to_s
      end
      refresh
    else
      perror 'Copy target must be a dir'
    end

  when :chdir
    change_dir File.dirname(text)

  when :zip
    print 'Archive name: '
    # target = gets().chomp
    target = readline
    return unless target
    return if target == ''

    # don't want a blank space or something screwing up
    if target && target.size > 3
      if File.exist? target
        perror "Target (#{target}) exists"
      else
        system "tar zcvf #{target} #{files}"
        setup_terminal
        refresh
      end
    end

  when :rename
    # 2019-03-07 NOTE works for single file FIXME
    # 2019-03-07 - TODO for n files replace pattern with string
    print "rename #{text} to : "
    target = readline
    return if target == ''

    text = File.expand_path(text)
    target = File.basename(text) if target == '.'
    if File.exist? target
      perror "Target (#{target}) exists"
    else
      FileUtils.mv text, target
      refresh
    end
  when :most, :less, :vim
    system "#{menu_text} #{files}"
    setup_terminal
    # should we remove from selection ?

  when :remspace
    # 2019-03-08 - 00:07 added replace space with underscore in filename
    print "Remove spaces from #{file}"
    pause
    farray = nil

    # stupidly using one variable for scalar and array DUH !
    case file
    when String
      farray = [file]
    when Array
      farray = file
    end

    farray.each do |f|
      if f.index ' '
        nname = f.tr(' ', '_')
        FileUtils.mv f, nname unless File.exist? nname
        # if success then remove from selection
      end
    end
    refresh
  when :execute
    execute
  when :page_stat_for_file
    1
    # already been executed by menu
    # We could have just put 'stat' in the menu but that doesn't look so nice
  else
    return unless menu_text

    print "#{menu_text} #{files}"
    pause
    print
    system "#{menu_text} #{files}"
    setup_terminal
    refresh
    pause
  end

  # remove non-existent files from select list due to move or delete
  #  or rename or whatever
  if sct > 0
    $selected_files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  end
end

# increase or decrease column
def columns_incdec(howmany)
  $gviscols += howmany.to_i
  $gviscols = 1 if $gviscols < 1
  $gviscols = 6 if $gviscols > 6
  $pagesize = $grows * $gviscols
end

# bind a key to an external command wich can be then be used for files
def bindkey_ext_command
  print
  pbold 'Bind a capital letter to an external command'
  print 'Enter a capital letter to bind: '
  key = get_char
  return if key == 'Q'

  if key =~ /^[A-Z]$/
    print "Enter an external command to bind to #{key}: "
    com = gets.chomp
    if com != ''
      print 'Enter prompt for command (blank if same as command): '
      pro = gets.chomp
      pro = com if pro == ''
    end
    print 'Pause after output [y/n]: '
    yn = get_char
    $bindings[key] = "command_file #{pro} #{yn} #{com}"
  end
end

# execute a command on selected or current file
def execute
  if $selected_files.empty?
    run_command current_file
    return
  end
  run_command $selected_files
end

def ag
  print 'Enter a pattern to search (ag): '
  pattern = readline
  return if pattern == ''

  $title = "Files found using 'ag' #{pattern}"
  system("ag #{pattern}")
  pause
  files = `ag -l #{pattern}`.split("\n")
  if files.empty?
    perror 'No files found for #{pattern}.'
    return
  end
  $files = files
  # redraw
end

def ffind
  print 'Enter a file name pattern to find: '
  pattern = readline
  return if pattern == ''

  $title = "Files found using 'find' #{pattern}"
  files = `find . -name "#{pattern}"`.split("\n")
  if files.empty?
    perror 'No files found. Try adding *'
  else
    $files = files
  end
  # redraw
end

def locate
  print 'Enter a file name pattern to locate: '
  pattern = readline
  return if pattern == ''

  $title = "Files found using 'locate' #{pattern}"
  files = `locate #{pattern}`.split("\n")
  files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  if files.empty?
    perror 'No files found.'
  else
    $files = files
  end
  # redraw
end

## Displays files from .viminfo file, if you use some other editor which
# tracks files opened then you can modify this accordingly.
# Neovim does not use viminfo
#
def viminfo
  file = File.expand_path('~/.viminfo')
  return unless File.exist? file
  $title = 'Files from ~/.viminfo'
  # $files = `grep '^>' ~/.viminfo | cut -d ' ' -f 2- | sed "s#~#$HOME#g"`.split("\n")
  $files = `grep '^>' ~/.viminfo | cut -d ' ' -f 2- `.split("\n")
  $files.select! { |x| x = File.expand_path(x); File.exist?(x) }
  # redraw
end

##  takes directories from the z program, if you use autojump you can
#   modify this accordingly
#
def z_interface
  file = File.expand_path('~/.z')
  return unless File.exist? file
  $title = 'Directories from ~/.z'
  $files = `sort -rn -k2 -t '|' ~/.z | cut -f1 -d '|'`.split("\n")
  home = ENV['HOME']
  # shorten file names
  $files.collect! do |f|
    f.sub(/#{home}/, '~')
  end
  # redraw
end

def vidir
  system 'vidir'
  setup_terminal
end

## some cursor movement functions
def cursor_scroll_dn
  moveto(pos + MSCROLL)
end

def cursor_scroll_up
  moveto(pos - MSCROLL)
end

def cursor_dn
  moveto(pos + 1)
end

def cursor_up
  moveto(pos - 1)
end

def pos
  $cursor
end

# move cursor to given position/line
def moveto(position)
  orig = $cursor
  $cursor = position
  $cursor = [$cursor, $view.size - 1].min
  $cursor = [$cursor, 0].max
  # 2019-03-18 - adding sta
  # $sta = position - only when page flips and file not visible
  # FIXME not correct, it must stop at end or correctly cycle
  # sta goes to 0 but cursor remains at 70
  # viewport.size may be wrong here, maybe should be pagesize only
  if $cursor - $sta >= $pagesize
    $sta += $pagesize
  # elsif $sta - $cursor >= $viewport.size
  end
  if $sta > $cursor
    $sta -= $pagesize
    # $sta = $cursor
  end

  star = [orig, $cursor].min
  fin = [orig, $cursor].max
  return unless $visual_mode

  # PWD has to be there in selction
  if selected? current_file
    # this depends on the direction
    # $selected_files = $selected_files - $view[star..fin]
    remove_from_selection $view[star..fin]
    ## current row remains in selection always.
    add_to_selection current_file
  else
    # $selected_files.concat $view[star..fin]
    add_to_selection $view[star..fin]
  end
ensure
  # redraw
end

# is given file in selected array
def selected?(file)
  $current_dir ||= Dir.pwd
  file = File.join($current_dir, file)
  return $selected_files.index file
end

# is given file in selected array
def visited?(file)
  $current_dir ||= Dir.pwd
  file = File.join($current_dir, file)
  return $visited_files.index file
end

# TODO: can be array
def add_to_selection(file)
  ff = file
  case file
  when String
    ff = [file]
  end
  $current_dir ||= Dir.pwd
  ff.each do |f|
    full = File.join($current_dir, f)
    $selected_files.push(full) unless $selected_files.include?(full)
  end
end

# TODO: can be array
def remove_from_selection(file)
  ff = file
  case file
  when String
    ff = [file]
  end
  $current_dir ||= Dir.pwd
  ff.each do |f|
    full = File.join($current_dir, f)
    $selected_files.delete full
  end
end

def visual_mode_toggle
  $mode = nil
  $visual_mode = !$visual_mode
  if $visual_mode
    $mode = 'VIS'
    $visual_block_start = $cursor
    add_to_selection current_file
  end
end

def visual_block_clear
  if $visual_block_start
    star = [$visual_block_start, $cursor].min
    fin = [$visual_block_start, $cursor].max
    remove_from_selection $view[star..fin]
  end
  $visual_block_start = nil
  $visual_mode = nil
end

def file_starting_with(first_char)
  ix = return_next_match(method(:file_matching?), "^#{first_char}")
  goto_line ix if ix
end

def file_matching?(file, patt)
  file =~ /#{patt}/
end

## generic method to take cursor to next position for a given condition
def return_next_match(binding, *args)
  first = nil
  ix = 0
  $view.each_with_index do |elem, ii|
    next unless binding.call(elem, *args)

    first ||= ii
    if ii > $cursor
      ix = ii
      break
    end
  end
  return first if ix == 0

  ix
end

##
# position cursor on a specific line which could be on a nother page
# therefore calculate the correct start offset of the display also.
def goto_line(pos)
  pages = ((pos * 1.00) / $pagesize).ceil
  pages -= 1
  $sta = pages * $pagesize + 1
  $cursor = pos
end

def filetype(f)
  return nil unless f

  f = Shellwords.escape(f)
  s = `file #{f}`
  if s.index 'text'
    return :text
  elsif s.index(/[Zz]ip/)
    return :zip
  elsif s.index('archive')
    return :zip
  elsif s.index 'image'
    return :image
  elsif s.index 'data'
    return :text
  end

  nil
end

# save offset in directory so we can revert to it when we return
def save_dir_pos
  # the next line meant that it would not save first directory.
  # return if $sta == 0 && $cursor == 0

  $dir_position[Dir.pwd] = [$sta, $cursor]
end

# revert to the position we were at in this directory
def revert_dir_pos
  $sta = 0
  $cursor = 0
  a = $dir_position[Dir.pwd]
  if a
    $sta = a.first
    $cursor = a[1]
    raise "sta is nil for #{Dir.pwd} : #{$dir_position[Dir.pwd]}" unless $sta
    raise 'cursor is nil' unless $cursor
  end
end

def create_a_dir
  print
  print 'Enter directory name: '
  str = readline
  return if str == ''

  if File.exist? str
    perror "#{str} exists."
    return
  end
  begin
    FileUtils.mkdir str
    $used_dirs.insert(0, str) if File.exist?(str)
    refresh
  rescue StandardError => ex
    perror "Error in newdir: #{ex}"
  end
end

def create_a_file
  print
  print 'Enter file name: '
  str = readline
  return if str.nil? || str == ''

  system %($EDITOR "#{str}")
  setup_terminal
  $visited_files.insert(0, str) if File.exist?(str)
  refresh
end

# convenience method to return file under cursor
def current_file
  $view[$cursor]
end

def current_or_selected_files
  return $selected_files if $selected_files.size > 0

  return [current_file]
end

# ------------------- scripts ------------------ #
# prompt for scripts to execute, giving selected file names
# NOTE: TODO 2019-03-21 - some scripts can output a filelist to display
def scripts
  write_selected_files
  # some scripts may work with the selected_files and not want to be called
  #  with filenames.
  title = 'Select a script'
  script_path = '~/.config/cetus/scripts'
  # TODO write selected files to a known file before calling
  binding = `find #{script_path} -type f | fzf --prompt="#{title.to_s} :"`
  return unless binding

  binding = binding.chomp if binding
  # TODO: check if binding is a file and executable
  # xargs only seems to take the first file
  # cf = current_or_selected_files.join('\0')
  # cf = Shellwords.join(current_or_selected_files)
  current_or_selected_files.each do |file|
    system %( #{binding} "#{file}" )
  end
  # system %(echo "#{cf}" | xargs #{binding})
  pause
end
# ------------- end of scripts --------------------------------#

# ------------------- view_selected_files ------------------ #
def view_selected_files
  fname = write_selected_files
  system "$PAGER #{fname}"
  setup_terminal
end
# ------------- end of view_selected_files --------------------------------#

# write selected files to a file and return path
def write_selected_files
  fname = File.join(File.dirname(CONFIG_FILE), 'selected_files')
  fname = File.expand_path(fname)

  File.open(fname, 'w') do |file|
    $selected_files.each { |row| file.puts row }
  end
  return fname
end
##
# Editing of the User Dir List.
# remove current entry from used dirs list, since we may not want some entries being there
#
def remove_from_list
  unless $selected_files.empty?
    sz = $selected_files.size
    print "Remove #{sz} files from used list (y)?: "
    key = get_char
    return if key != 'y'

    arr = $selected_files.map { |path| File.expand_path(path) }

    $used_dirs = $used_dirs - arr
    $visited_files = $visited_files - arr
    unselect_all
    $modified = true
    refresh
    return
  end

  # no file selected, use file under cursor
  print
  ## what if selected some rows
  file = $view[$cursor]
  print "Remove #{file} from used list (y)?: "
  key = get_char
  return if key != 'y'

  file = File.expand_path(file)
  if File.directory? file
    $used_dirs.delete(file)
  else
    $visited_files.delete(file)
  end
  refresh
  $modified = true
end

#
# If there's a short file list, take recently mod and accessed folders and put latest
# files from there and insert it here. I take both since recent mod can be binaries / object
# files and gems created by a process, and not actually edited files. Recent accessed gives
# latest source, but in some cases even this can be misleading since running a program accesses
# include files.
def enhance_file_list
  return unless $enhanced_mode

  # zshglob: M = MARK_DIRS with slash
  # zshglob: N = NULL_GLOB no error if no result, this is causing space to split
  #  file sometimes for single file.

  # if only one entry and its a dir
  # get its children and maybe the recent mod files a few
  if $files.size == 1
    # its a dir, let give the next level at least
    if $files.first[-1] == '/'
      d = $files.first
      # zshglob: 'om' = ordered on modification time
      f = `zsh -c 'print -rn -- #{d}*(omM)'`.split("\n")
      # TODO: use ruby this throws errors if not files
      if f && !f.empty?
        @log.debug "CONCAT: #{f}"
        @log.debug "CONCAT: #{f}"
        $files.concat f
        $files.concat get_important_files(d)
        return
      end
    else
      # just a file, not dirs here
      return
    end
  end
  #
  # check if a ruby project dir, although it could be a backup file too,
  # if so , expand lib and maybe bin, put a couple recent files
  #
  if $files.index('Gemfile') || !$files.grep(/\.gemspec/).empty?
    # usually the lib dir has only one file and one dir
    flg = false
    $files.concat get_important_files(Dir.pwd)
    if $files.index('lib/')
      # get first five entries by modification time
      f = `zsh -c 'print -rl -- lib/*(om[1,5]MN)'`.split("\n")
      if f && !f.empty?
        insert_into_list('lib/', f)
        flg = true
      end

      # look into lib file for that project
      dd = File.basename(Dir.pwd)
      if f.index("lib/#{dd}/")
        f = `zsh -c 'print -rl -- lib/#{dd}/*(om[1,5]MN)'`.split("\n")
        if f && !f.empty?
          insert_into_list("lib/#{dd}/", f)
          flg = true
        end
      end
    end

    # look into bin directory and get first five modified files
    if $files.index('bin/')
      f = `zsh -c 'print -rl -- bin/*(om[1,5]MN)'`.split("\n")
      insert_into_list('bin/', f) if f && !f.empty?
      flg = true
    end
    return if flg

    # lib has a dir in it with the gem name

  end
  return if $files.size > 15

  # Get most recently accessed directory
  ## NOTE: first check accessed else modified will change accessed
  # 2019-03-28 - adding NULL_GLOB breaks file name on spaces
  # print -n : don't add newline
  zzmoda = `zsh -c 'print -rn -- *(/oa[1]MN)'`
  zzmoda = nil if zzmoda == ''
  moda = get_most_recently_accessed_dir
  raise "Error 2663 #{zzmoda} != #{moda}" if zzmoda != moda
  if moda && moda != ''

    # get most recently accessed file in that directory
    # NOTE: adding NULL_GLOB splits files on spaces
    zzmodf = `zsh -c 'print -rl -- #{moda}*(oa[1]M)'`.chomp
    zzmodf = nil if zzmodf == ''
    modf = get_most_recently_accessed_file moda
    raise "Error 2670 (#{zzmodf}) != (#{modf}) gmra in #{moda} #{zzmodf.class}, #{modf.class}" if zzmodf != modf

    insert_into_list moda, modf if modf && modf != ''

    # get most recently modified file in that directory
    zzmodm = `zsh -c 'print -rn -- #{moda}*(om[1]M)'`.chomp
    modm = get_most_recently_modified_file moda
    zzmodm = nil if zzmodm == ''
    raise "Error 2678 #{zzmodm} != #{modm}" if zzmodm != modm
    insert_into_list moda, modm if modm && modm != '' && modm != modf
  end

  ## get most recently modified dir
  zzmodm = `zsh -c 'print -rn -- *(/om[1]M)'`
  zzmodm = nil if zzmodm == ''
  modm = get_most_recently_modified_dir
  raise "Error 2686 #{zzmodm} != #{modm}" if zzmodm != modm
  if modm != moda

    # get most recently accessed file in that directory
    modmf = `zsh -c 'print -rn -- #{modm}*(oa[1]M)'`
    modmf = get_most_recently_accessed_file modm
    insert_into_list modm, modmf

    # get most recently modified file in that directory
    modmf1 = `zsh -c 'print -rn -- #{modm}*(om[1]M)'`
    modmf1 = get_most_recently_modified_file modm
    insert_into_list(modm, modmf1) if modmf1 != modmf
  else
    # if both are same then our options get reduced so we need to get something more
    # If you access the latest mod dir, then come back you get only one, since mod and accessed
    # are the same dir, so we need to find the second modified dir
  end
end

# insert important files to end of $files
def insert_into_list _dir, file
  @log.debug "INSERT: " + file.class.to_s
  @log.debug "INSERT: " + file.to_s
  # ix = $files.index(dir)
  # raise "something wrong can find #{dir}." unless ix
  # $files.insert ix, *file
  # 2013-03-19 - 19:42 adding at end to avoid confusion
  # $files.concat file
  $files.push(*file)
end

# 2019-03-23 - not exactly clear what is happening XXX
# this gets a directory (containing '/' at end)
def get_important_files dir
  # checks various lists like visited_files and bookmarks
  # to see if files from this dir or below are in it.
  # More to be used in a dir with few files.
  list = []
  l = dir.size + 1
  # 2019-03-23 - i think we are getting the basename of the file
  #  if it is present in the given directory XXX
  $visited_files.each do |e|
    list << e[l..-1] if e.index(dir) == 0
  end
  # bookmarks if it starts with this directory then add it
  # FIXME it puts same directory cetus into the list with full path
  # We need to remove the base until this dir. get relative part
  list1 = $bookmarks.values.select do |e|
    e.index(dir) == 0 && e != dir
  end
  list.concat list1
  list
end

def get_most_recently_accessed_dir dir='.'
  file = Dir.glob(dir + '/*')
            .select { |f| File.directory?(f) }
            .max_by { |f| File.atime(f) }
  return File.basename(file) + '/' if file

  return nil
end

def get_most_recently_accessed_file dir='.'
  file = Dir.glob(dir + '/*')
            .select { |f| File.file?(f) }
            .max_by { |f| File.atime(f) }
  # return File.basename(file) if file
  return file.gsub('//','/') if file

  return nil
end

def get_most_recently_modified_file dir='.'
  file = Dir.glob(dir + '/*')
            .select { |f| File.file?(f) }
            .max_by { |f| File.mtime(f) }
  # return File.basename(file) if file
  return file.gsub('//','/') if file

  return nil
end

def get_most_recently_modified_dir dir='.'
  file = Dir.glob(dir + '/*')
            .select { |f| File.directory?(f) }
            .max_by { |f| File.mtime(f) }
  return File.basename(file) +'/' if file

  return nil
end


# set message which will be displayed in status line
def message mess
  $message = mess
end

def last_line
  system "tput cup #{$glines} 0"
end

def clear_status_line
  last_line
  # print a colored line at bottom of screen
  # \e[33;41m  - set color of status_line
  # %*s        - set blank spaces for entire line
  print "\e[33;4%sm%*s" % [$status_color || '1', $gcols, " "]
end
def print_on_right text
  sz = text.size
  system "tput cup #{$glines} #{$gcols - sz -1}"
  print text
end

def print_last_line text
  last_line
  print text
end

# main loop which calls all other programs
def run

  Signal.trap('EXIT') do
    reset_terminal
    exit
  end

  setup_terminal
  config_read
  parse_ls_colors

  redraw true

  # do we need this, have they changed after redraw
  $patt = nil
  $sta = 0

  # forever loop that prints dir and takes a key
  loop do

    key = get_char
    resolve_key key
    redraw rescan?

    break if $quitting
  end
  write_curdir
  puts 'bye'
  config_write if $writing
  @log&.close
end

run
